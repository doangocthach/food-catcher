{"ast":null,"code":"/**\n * Shader utilities for kami.\n * \n * @module kami-shader\n */\nvar Class = require('klasse');\n\nvar compileShader = require('webgl-compile-shader');\n\nvar wrapContext = require('kami-util').wrapContext;\n\nvar ShaderProgram = new Class({\n  /**\n   * Creates a new ShaderProgram from the given source, and an optional map of attribute\n   * locations as <name, index> pairs.\n   *\n   * _Note:_ Chrome version 31 was giving me issues with attribute locations -- you may\n   * want to omit this to let the browser pick the locations for you.\t\n   *\n   * @class  ShaderProgram\n   * @constructor\n   * @param  {WebGLRenderingContext|WebGLContext} context      the context to manage this object\n   * @param  {String} vertSource         the vertex shader source\n   * @param  {String} fragSource         the fragment shader source\n   * @param  {Object} attributeLocations the attribute locations\n   */\n  initialize: function ShaderProgram(context, vertSource, fragSource, attributeLocations) {\n    if (!vertSource || !fragSource) throw \"vertex and fragment shaders must be defined\";\n    if (!context || typeof context !== \"object\") throw \"valid GL context not specified to ShaderProgram\";\n    this.context = wrapContext(context);\n    this.vertShader = null;\n    this.fragShader = null;\n    this.program = null;\n    this.log = \"\";\n    this.uniformCache = null;\n    this.attributeCache = null;\n    this.attributeLocations = attributeLocations; //We trim so that the GLSL line numbers are\n    //accurate on shader log\n\n    this.vertSource = vertSource.trim();\n    this.fragSource = fragSource.trim(); //Adds this shader to the context, to be managed\n    //This has no effect if the passed context is not a kami-context type\n\n    this.context.addManagedObject(this);\n    this.create();\n  },\n\n  /** \n   * This is called during the ShaderProgram constructor,\n   * and may need to be called again after context loss and restore.\n   * \n   * @method  create\n   */\n  create: function create() {\n    this.gl = this.context.gl;\n\n    this._compileShaders();\n  },\n  //Compiles the shaders, throwing an error if the program was invalid.\n  _compileShaders: function _compileShaders() {\n    var gl = this.gl;\n    var info = compileShader({\n      gl: gl,\n      vertex: this.vertSource,\n      fragment: this.fragSource,\n      verbose: ShaderProgram.VERBOSE_COMPILE,\n      attributeLocations: this.attributeLocations\n    });\n    this.log = info.log;\n    this.program = info.program;\n    this.vertShader = info.vertex;\n    this.fragShader = info.fragment;\n    if (ShaderProgram.VERBOSE_COMPILE && this.log) console.warn(this.log);\n\n    this._fetchUniforms();\n\n    this._fetchAttributes();\n  },\n  _fetchUniforms: function _fetchUniforms() {\n    var gl = this.gl;\n    this.uniformCache = {};\n    var len = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);\n    if (!len) //null or zero\n      return;\n\n    for (var i = 0; i < len; i++) {\n      var info = gl.getActiveUniform(this.program, i);\n      if (info === null) continue;\n      var name = info.name;\n      var location = gl.getUniformLocation(this.program, name);\n      this.uniformCache[name] = {\n        size: info.size,\n        type: info.type,\n        location: location\n      };\n    }\n  },\n  _fetchAttributes: function _fetchAttributes() {\n    var gl = this.gl;\n    this.attributeCache = {};\n    var len = gl.getProgramParameter(this.program, gl.ACTIVE_ATTRIBUTES);\n    if (!len) //null or zero\n      return;\n\n    for (var i = 0; i < len; i++) {\n      var info = gl.getActiveAttrib(this.program, i);\n      if (info === null) continue;\n      var name = info.name; //the attrib location is a simple index\n\n      var location = gl.getAttribLocation(this.program, name);\n      this.attributeCache[name] = {\n        size: info.size,\n        type: info.type,\n        location: location\n      };\n    }\n  },\n\n  /**\n   * Called to bind this shader. Note that there is no \"unbind\" since\n   * technically such a thing is not possible in the programmable pipeline.\n   *\n   * You must bind a shader before settings its uniforms.\n   * \n   * @method bind\n   */\n  bind: function bind() {\n    this.gl.useProgram(this.program);\n  },\n\n  /**\n   * Destroys this shader and its resources. You should not try to use this\n   * after destroying it.\n   * @method  destroy\n   */\n  destroy: function destroy() {\n    if (this.context) this.context.removeManagedObject(this);\n\n    if (this.gl && this.program) {\n      var gl = this.gl;\n      gl.detachShader(this.program, this.vertShader);\n      gl.detachShader(this.program, this.fragShader);\n      gl.deleteShader(this.vertShader);\n      gl.deleteShader(this.fragShader);\n      gl.deleteProgram(this.program);\n    }\n\n    this.attributeCache = null;\n    this.uniformCache = null;\n    this.vertShader = null;\n    this.fragShader = null;\n    this.program = null;\n    this.gl = null;\n    this.context = null;\n  },\n\n  /**\n   * Returns the cached uniform info (size, type, location).\n   * If the uniform is not found in the cache, it is assumed\n   * to not exist, and this method returns null.\n   *\n   * This may return null even if the uniform is defined in GLSL:\n   * if it is _inactive_ (i.e. not used in the program) then it may\n   * be optimized out.\n   *\n   * @method  getUniformInfo\n   * @param  {String} name the uniform name as defined in GLSL\n   * @return {Object} an object containing location, size, and type\n   */\n  getUniformInfo: function getUniformInfo(name) {\n    return this.uniformCache[name] || null;\n  },\n\n  /**\n   * Returns the cached attribute info (size, type, location).\n   * If the attribute is not found in the cache, it is assumed\n   * to not exist, and this method returns null.\n   *\n   * This may return null even if the attribute is defined in GLSL:\n   * if it is _inactive_ (i.e. not used in the program or disabled) \n   * then it may be optimized out.\n   *\n   * @method  getAttributeInfo\n   * @param  {String} name the attribute name as defined in GLSL\n   * @return {object} an object containing location, size and type\n   */\n  getAttributeInfo: function getAttributeInfo(name) {\n    return this.attributeCache[name] || null;\n  },\n\n  /**\n   * Returns the cached uniform location object.\n   * If the uniform is not found, this method returns null.\n   *\n   * @method  getAttributeLocation\n   * @param  {String} name the uniform name as defined in GLSL\n   * @return {GLint} the location object\n   */\n  getAttributeLocation: function getAttributeLocation(name) {\n    //TODO: make faster, don't cache\n    var info = this.getAttributeInfo(name);\n    return info ? info.location : null;\n  },\n\n  /**\n   * Returns the cached uniform location object, assuming it exists\n   * and is active. Note that uniforms may be inactive if \n   * the GLSL compiler deemed them unused.\n   *\n   * @method  getUniformLocation\n   * @param  {String} name the uniform name as defined in GLSL\n   * @return {WebGLUniformLocation} the location object\n   */\n  getUniformLocation: function getUniformLocation(name) {\n    var info = this.getUniformInfo(name);\n    return info ? info.location : null;\n  },\n\n  /**\n   * Returns true if the uniform is active and found in this\n   * compiled program. Note that uniforms may be inactive if \n   * the GLSL compiler deemed them unused.\n   *\n   * @method  hasUniform\n   * @param  {String}  name the uniform name\n   * @return {Boolean} true if the uniform is found and active\n   */\n  hasUniform: function hasUniform(name) {\n    return this.getUniformInfo(name) !== null;\n  },\n\n  /**\n   * Returns true if the attribute is active and found in this\n   * compiled program.\n   *\n   * @method  hasAttribute\n   * @param  {String}  name the attribute name\n   * @return {Boolean} true if the attribute is found and active\n   */\n  hasAttribute: function hasAttribute(name) {\n    return this.getAttributeInfo(name) !== null;\n  },\n\n  /**\n   * Returns the uniform value by name.\n   *\n   * @method  getUniform\n   * @param  {String} name the uniform name as defined in GLSL\n   * @return {any} The value of the WebGL uniform\n   */\n  getUniform: function getUniform(name) {\n    return this.gl.getUniform(this.program, this.getUniformLocation(name));\n  },\n\n  /**\n   * Returns the uniform value at the specified WebGLUniformLocation.\n   *\n   * @method  getUniformAt\n   * @param  {WebGLUniformLocation} location the location object\n   * @return {any} The value of the WebGL uniform\n   */\n  getUniformAt: function getUniformAt(location) {\n    return this.gl.getUniform(this.program, location);\n  },\n\n  /**\n   * A convenience method to set uniformi from the given arguments.\n   * We determine which GL call to make based on the number of arguments\n   * passed. For example, `setUniformi(\"var\", 0, 1)` maps to `gl.uniform2i`.\n   * \n   * @method  setUniformi\n   * @param {String} name        \t\tthe name of the uniform\n   * @param {GLint} x  the x component for ints\n   * @param {GLint} y  the y component for ivec2\n   * @param {GLint} z  the z component for ivec3\n   * @param {GLint} w  the w component for ivec4\n   */\n  setUniformi: function setUniformi(name, x, y, z, w) {\n    'use strict';\n\n    var gl = this.gl;\n    var loc = this.getUniformLocation(name);\n    if (loc === null) return false;\n\n    switch (arguments.length) {\n      case 2:\n        gl.uniform1i(loc, x);\n        return true;\n\n      case 3:\n        gl.uniform2i(loc, x, y);\n        return true;\n\n      case 4:\n        gl.uniform3i(loc, x, y, z);\n        return true;\n\n      case 5:\n        gl.uniform4i(loc, x, y, z, w);\n        return true;\n\n      default:\n        throw \"invalid arguments to setUniformi\";\n    }\n  },\n\n  /**\n   * A convenience method to set uniformf from the given arguments.\n   * We determine which GL call to make based on the number of arguments\n   * passed. For example, `setUniformf(\"var\", 0, 1)` maps to `gl.uniform2f`.\n   * \n   * @method  setUniformf\n   * @param {String} name        \t\tthe name of the uniform\n   * @param {GLfloat} x  the x component for floats\n   * @param {GLfloat} y  the y component for vec2\n   * @param {GLfloat} z  the z component for vec3\n   * @param {GLfloat} w  the w component for vec4\n   */\n  setUniformf: function setUniformf(name, x, y, z, w) {\n    'use strict';\n\n    var gl = this.gl;\n    var loc = this.getUniformLocation(name);\n    if (loc === null) return false;\n\n    switch (arguments.length) {\n      case 2:\n        gl.uniform1f(loc, x);\n        return true;\n\n      case 3:\n        gl.uniform2f(loc, x, y);\n        return true;\n\n      case 4:\n        gl.uniform3f(loc, x, y, z);\n        return true;\n\n      case 5:\n        gl.uniform4f(loc, x, y, z, w);\n        return true;\n\n      default:\n        throw \"invalid arguments to setUniformf\";\n    }\n  },\n  //I guess we won't support sequence<GLfloat> .. whatever that is ??\n  ///// \n\n  /**\n   * A convenience method to set uniformNfv from the given ArrayBuffer.\n   * We determine which GL call to make based on the length of the array \n   * buffer (for 1-4 component vectors stored in a Float32Array). To use\n   * this method to upload data to uniform arrays, you need to specify the\n   * 'count' parameter; i.e. the data type you are using for that array. If\n   * specified, this will dictate whether to call uniform1fv, uniform2fv, etc.\n   *\n   * @method  setUniformfv\n   * @param {String} name        \t\tthe name of the uniform\n   * @param {ArrayBuffer} arrayBuffer the array buffer\n   * @param {Number} count            optional, the explicit data type count, e.g. 2 for vec2\n   */\n  setUniformfv: function setUniformfv(name, arrayBuffer, count) {\n    'use strict';\n\n    count = count || arrayBuffer.length;\n    var gl = this.gl;\n    var loc = this.getUniformLocation(name);\n    if (loc === null) return false;\n\n    switch (count) {\n      case 1:\n        gl.uniform1fv(loc, arrayBuffer);\n        return true;\n\n      case 2:\n        gl.uniform2fv(loc, arrayBuffer);\n        return true;\n\n      case 3:\n        gl.uniform3fv(loc, arrayBuffer);\n        return true;\n\n      case 4:\n        gl.uniform4fv(loc, arrayBuffer);\n        return true;\n\n      default:\n        throw \"invalid arguments to setUniformf\";\n    }\n  },\n\n  /**\n   * A convenience method to set uniformNiv from the given ArrayBuffer.\n   * We determine which GL call to make based on the length of the array \n   * buffer (for 1-4 component vectors stored in a int array). To use\n   * this method to upload data to uniform arrays, you need to specify the\n   * 'count' parameter; i.e. the data type you are using for that array. If\n   * specified, this will dictate whether to call uniform1fv, uniform2fv, etc.\n   *\n   * @method  setUniformiv\n   * @param {String} name        \t\tthe name of the uniform\n   * @param {ArrayBuffer} arrayBuffer the array buffer\n   * @param {Number} count            optional, the explicit data type count, e.g. 2 for ivec2\n   */\n  setUniformiv: function setUniformiv(name, arrayBuffer, count) {\n    'use strict';\n\n    count = count || arrayBuffer.length;\n    var gl = this.gl;\n    var loc = this.getUniformLocation(name);\n    if (loc === null) return false;\n\n    switch (count) {\n      case 1:\n        gl.uniform1iv(loc, arrayBuffer);\n        return true;\n\n      case 2:\n        gl.uniform2iv(loc, arrayBuffer);\n        return true;\n\n      case 3:\n        gl.uniform3iv(loc, arrayBuffer);\n        return true;\n\n      case 4:\n        gl.uniform4iv(loc, arrayBuffer);\n        return true;\n\n      default:\n        throw \"invalid arguments to setUniformf\";\n    }\n  },\n\n  /**\n   * This is a convenience function to pass a Matrix3 (from vecmath,\n   * kami's preferred math library) or a Float32Array (e.g. gl-matrix)\n   * to a shader. If mat is an object with \"val\", it is considered to be\n   * a Matrix3, otherwise assumed to be a typed array being passed directly\n   * to the shader.\n   * \n   * @param {String} name the uniform name\n   * @param {Matrix3|Float32Array} mat a Matrix3 or Float32Array\n   * @param {Boolean} transpose whether to transpose the matrix, default false\n   */\n  setUniformMatrix3: function setUniformMatrix3(name, mat, transpose) {\n    'use strict';\n\n    var arr = typeof mat === \"object\" && mat.val ? mat.val : mat;\n    transpose = !!transpose; //to boolean\n\n    var gl = this.gl;\n    var loc = this.getUniformLocation(name);\n    if (loc === null) return false;\n    gl.uniformMatrix3fv(loc, transpose, arr);\n  },\n\n  /**\n   * This is a convenience function to pass a Matrix4 (from vecmath,\n   * kami's preferred math library) or a Float32Array (e.g. gl-matrix)\n   * to a shader. If mat is an object with \"val\", it is considered to be\n   * a Matrix4, otherwise assumed to be a typed array being passed directly\n   * to the shader.\n   * \n   * @param {String} name the uniform name\n   * @param {Matrix4|Float32Array} mat a Matrix4 or Float32Array\n   * @param {Boolean} transpose whether to transpose the matrix, default false\n   */\n  setUniformMatrix4: function setUniformMatrix4(name, mat, transpose) {\n    'use strict';\n\n    var arr = typeof mat === \"object\" && mat.val ? mat.val : mat;\n    transpose = !!transpose; //to boolean\n\n    var gl = this.gl;\n    var loc = this.getUniformLocation(name);\n    if (loc === null) return false;\n    gl.uniformMatrix4fv(loc, transpose, arr);\n  }\n}); //Some default attribute names that parts of kami will use\n//when creating a standard shader.\n\nShaderProgram.POSITION_ATTRIBUTE = \"Position\";\nShaderProgram.NORMAL_ATTRIBUTE = \"Normal\";\nShaderProgram.COLOR_ATTRIBUTE = \"Color\";\nShaderProgram.TEXCOORD_ATTRIBUTE = \"TexCoord\";\n/**\n * Whether to include verbose warnings during shader compilation.\n * This includes:\n *\n *   - Printing full shaders (with line numbers) when there is an error\n *   - Printing warnings even if the shader compiled successfully \n *   \n * @property {Boolean} VERBOSE_COMPILE\n */\n\nShaderProgram.VERBOSE_COMPILE = true;\nmodule.exports = ShaderProgram;","map":{"version":3,"sources":["E:/fcatcher-client/node_modules/kami-shader/index.js"],"names":["Class","require","compileShader","wrapContext","ShaderProgram","initialize","context","vertSource","fragSource","attributeLocations","vertShader","fragShader","program","log","uniformCache","attributeCache","trim","addManagedObject","create","gl","_compileShaders","info","vertex","fragment","verbose","VERBOSE_COMPILE","console","warn","_fetchUniforms","_fetchAttributes","len","getProgramParameter","ACTIVE_UNIFORMS","i","getActiveUniform","name","location","getUniformLocation","size","type","ACTIVE_ATTRIBUTES","getActiveAttrib","getAttribLocation","bind","useProgram","destroy","removeManagedObject","detachShader","deleteShader","deleteProgram","getUniformInfo","getAttributeInfo","getAttributeLocation","hasUniform","hasAttribute","getUniform","getUniformAt","setUniformi","x","y","z","w","loc","arguments","length","uniform1i","uniform2i","uniform3i","uniform4i","setUniformf","uniform1f","uniform2f","uniform3f","uniform4f","setUniformfv","arrayBuffer","count","uniform1fv","uniform2fv","uniform3fv","uniform4fv","setUniformiv","uniform1iv","uniform2iv","uniform3iv","uniform4iv","setUniformMatrix3","mat","transpose","arr","val","uniformMatrix3fv","setUniformMatrix4","uniformMatrix4fv","POSITION_ATTRIBUTE","NORMAL_ATTRIBUTE","COLOR_ATTRIBUTE","TEXCOORD_ATTRIBUTE","module","exports"],"mappings":"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","sourcesContent":["/**\n * Shader utilities for kami.\n * \n * @module kami-shader\n */\n\nvar Class = require('klasse');\nvar compileShader = require('webgl-compile-shader');\nvar wrapContext = require('kami-util').wrapContext;\n\nvar ShaderProgram = new Class({\n\t\n\t/**\n\t * Creates a new ShaderProgram from the given source, and an optional map of attribute\n\t * locations as <name, index> pairs.\n\t *\n\t * _Note:_ Chrome version 31 was giving me issues with attribute locations -- you may\n\t * want to omit this to let the browser pick the locations for you.\t\n\t *\n\t * @class  ShaderProgram\n\t * @constructor\n\t * @param  {WebGLRenderingContext|WebGLContext} context      the context to manage this object\n\t * @param  {String} vertSource         the vertex shader source\n\t * @param  {String} fragSource         the fragment shader source\n\t * @param  {Object} attributeLocations the attribute locations\n\t */\n\tinitialize: function ShaderProgram(context, vertSource, fragSource, attributeLocations) {\n\t\tif (!vertSource || !fragSource)\n\t\t\tthrow \"vertex and fragment shaders must be defined\";\n\t\tif (!context || typeof context !== \"object\")\n\t\t\tthrow \"valid GL context not specified to ShaderProgram\";\n\n\t\tthis.context = wrapContext(context);\n\n\t\tthis.vertShader = null;\n\t\tthis.fragShader = null;\n\t\tthis.program = null;\n\t\tthis.log = \"\";\n\n\t\tthis.uniformCache = null;\n\t\tthis.attributeCache = null;\n\n\t\tthis.attributeLocations = attributeLocations;\n\n\t\t//We trim so that the GLSL line numbers are\n\t\t//accurate on shader log\n\t\tthis.vertSource = vertSource.trim();\n\t\tthis.fragSource = fragSource.trim();\n\n\t\t//Adds this shader to the context, to be managed\n\t\t//This has no effect if the passed context is not a kami-context type\n\t\tthis.context.addManagedObject(this);\n\t\tthis.create();\n\t},\n\n\t/** \n\t * This is called during the ShaderProgram constructor,\n\t * and may need to be called again after context loss and restore.\n\t * \n\t * @method  create\n\t */\n\tcreate: function() {\n\t\tthis.gl = this.context.gl;\n\t\tthis._compileShaders();\n\t},\n\n\t//Compiles the shaders, throwing an error if the program was invalid.\n\t_compileShaders: function() {\n\t\tvar gl = this.gl; \n\t\t\n\t\tvar info = compileShader({\n\t\t\tgl: gl,\n\t\t\tvertex: this.vertSource,\n\t\t\tfragment: this.fragSource,\n\t\t\tverbose: ShaderProgram.VERBOSE_COMPILE,\n\t\t\tattributeLocations: this.attributeLocations\n\t\t});\n\n\t\tthis.log = info.log;\n\t\tthis.program = info.program;\n\t\tthis.vertShader = info.vertex;\n\t\tthis.fragShader = info.fragment;\n\t\t\n\t\tif (ShaderProgram.VERBOSE_COMPILE && this.log)\n\t\t\tconsole.warn(this.log);\n\n\t\tthis._fetchUniforms();\n\t\tthis._fetchAttributes();\n\t},\n\n\t_fetchUniforms: function() {\n\t\tvar gl = this.gl;\n\n\t\tthis.uniformCache = {};\n\n\t\tvar len = gl.getProgramParameter(this.program, gl.ACTIVE_UNIFORMS);\n\t\tif (!len) //null or zero\n\t\t\treturn;\n\n\t\tfor (var i=0; i<len; i++) {\n\t\t\tvar info = gl.getActiveUniform(this.program, i);\n\t\t\tif (info === null) \n\t\t\t\tcontinue;\n\t\t\tvar name = info.name;\n\t\t\tvar location = gl.getUniformLocation(this.program, name);\n\t\t\t\n\t\t\tthis.uniformCache[name] = {\n\t\t\t\tsize: info.size,\n\t\t\t\ttype: info.type,\n\t\t\t\tlocation: location\n\t\t\t};\n\t\t}\n\t},\n\n\t_fetchAttributes: function() { \n\t\tvar gl = this.gl; \n\n\t\tthis.attributeCache = {};\n\n\t\tvar len = gl.getProgramParameter(this.program, gl.ACTIVE_ATTRIBUTES);\n\t\tif (!len) //null or zero\n\t\t\treturn;\t\n\n\t\tfor (var i=0; i<len; i++) {\n\t\t\tvar info = gl.getActiveAttrib(this.program, i);\n\t\t\tif (info === null) \n\t\t\t\tcontinue;\n\t\t\tvar name = info.name;\n\n\t\t\t//the attrib location is a simple index\n\t\t\tvar location = gl.getAttribLocation(this.program, name);\n\t\t\t\n\t\t\tthis.attributeCache[name] = {\n\t\t\t\tsize: info.size,\n\t\t\t\ttype: info.type,\n\t\t\t\tlocation: location\n\t\t\t};\n\t\t}\n\t},\n\n\t/**\n\t * Called to bind this shader. Note that there is no \"unbind\" since\n\t * technically such a thing is not possible in the programmable pipeline.\n\t *\n\t * You must bind a shader before settings its uniforms.\n\t * \n\t * @method bind\n\t */\n\tbind: function() {\n\t\tthis.gl.useProgram(this.program);\n\t},\n\n\n\t/**\n\t * Destroys this shader and its resources. You should not try to use this\n\t * after destroying it.\n\t * @method  destroy\n\t */\n\tdestroy: function() {\n\t\tif (this.context)\n\t\t\tthis.context.removeManagedObject(this);\n\n\t\tif (this.gl && this.program) {\n\t\t\tvar gl = this.gl;\n\n\t\t    gl.detachShader(this.program, this.vertShader);\n\t\t    gl.detachShader(this.program, this.fragShader);\n\t\t    gl.deleteShader(this.vertShader);\n\t\t    gl.deleteShader(this.fragShader);\n\n\t\t\tgl.deleteProgram(this.program);\n\t\t}\n\t\tthis.attributeCache = null;\n\t\tthis.uniformCache = null;\n\t\tthis.vertShader = null;\n\t\tthis.fragShader = null;\n\t\tthis.program = null;\n\t\tthis.gl = null;\n\t\tthis.context = null;\n\t},\n\n\t/**\n\t * Returns the cached uniform info (size, type, location).\n\t * If the uniform is not found in the cache, it is assumed\n\t * to not exist, and this method returns null.\n\t *\n\t * This may return null even if the uniform is defined in GLSL:\n\t * if it is _inactive_ (i.e. not used in the program) then it may\n\t * be optimized out.\n\t *\n\t * @method  getUniformInfo\n\t * @param  {String} name the uniform name as defined in GLSL\n\t * @return {Object} an object containing location, size, and type\n\t */\n\tgetUniformInfo: function(name) {\n\t\treturn this.uniformCache[name] || null; \n\t},\n\n\t/**\n\t * Returns the cached attribute info (size, type, location).\n\t * If the attribute is not found in the cache, it is assumed\n\t * to not exist, and this method returns null.\n\t *\n\t * This may return null even if the attribute is defined in GLSL:\n\t * if it is _inactive_ (i.e. not used in the program or disabled) \n\t * then it may be optimized out.\n\t *\n\t * @method  getAttributeInfo\n\t * @param  {String} name the attribute name as defined in GLSL\n\t * @return {object} an object containing location, size and type\n\t */\n\tgetAttributeInfo: function(name) {\n\t\treturn this.attributeCache[name] || null; \n\t},\n\n\n\t/**\n\t * Returns the cached uniform location object.\n\t * If the uniform is not found, this method returns null.\n\t *\n\t * @method  getAttributeLocation\n\t * @param  {String} name the uniform name as defined in GLSL\n\t * @return {GLint} the location object\n\t */\n\tgetAttributeLocation: function(name) { //TODO: make faster, don't cache\n\t\tvar info = this.getAttributeInfo(name);\n\t\treturn info ? info.location : null;\n\t},\n\n\t/**\n\t * Returns the cached uniform location object, assuming it exists\n\t * and is active. Note that uniforms may be inactive if \n\t * the GLSL compiler deemed them unused.\n\t *\n\t * @method  getUniformLocation\n\t * @param  {String} name the uniform name as defined in GLSL\n\t * @return {WebGLUniformLocation} the location object\n\t */\n\tgetUniformLocation: function(name) {\n\t\tvar info = this.getUniformInfo(name);\n\t\treturn info ? info.location : null;\n\t},\n\n\t/**\n\t * Returns true if the uniform is active and found in this\n\t * compiled program. Note that uniforms may be inactive if \n\t * the GLSL compiler deemed them unused.\n\t *\n\t * @method  hasUniform\n\t * @param  {String}  name the uniform name\n\t * @return {Boolean} true if the uniform is found and active\n\t */\n\thasUniform: function(name) {\n\t\treturn this.getUniformInfo(name) !== null;\n\t},\n\n\t/**\n\t * Returns true if the attribute is active and found in this\n\t * compiled program.\n\t *\n\t * @method  hasAttribute\n\t * @param  {String}  name the attribute name\n\t * @return {Boolean} true if the attribute is found and active\n\t */\n\thasAttribute: function(name) {\n\t\treturn this.getAttributeInfo(name) !== null;\n\t},\n\n\t/**\n\t * Returns the uniform value by name.\n\t *\n\t * @method  getUniform\n\t * @param  {String} name the uniform name as defined in GLSL\n\t * @return {any} The value of the WebGL uniform\n\t */\n\tgetUniform: function(name) {\n\t\treturn this.gl.getUniform(this.program, this.getUniformLocation(name));\n\t},\n\n\t/**\n\t * Returns the uniform value at the specified WebGLUniformLocation.\n\t *\n\t * @method  getUniformAt\n\t * @param  {WebGLUniformLocation} location the location object\n\t * @return {any} The value of the WebGL uniform\n\t */\n\tgetUniformAt: function(location) {\n\t\treturn this.gl.getUniform(this.program, location);\n\t},\n\n\t/**\n\t * A convenience method to set uniformi from the given arguments.\n\t * We determine which GL call to make based on the number of arguments\n\t * passed. For example, `setUniformi(\"var\", 0, 1)` maps to `gl.uniform2i`.\n\t * \n\t * @method  setUniformi\n\t * @param {String} name        \t\tthe name of the uniform\n\t * @param {GLint} x  the x component for ints\n\t * @param {GLint} y  the y component for ivec2\n\t * @param {GLint} z  the z component for ivec3\n\t * @param {GLint} w  the w component for ivec4\n\t */\n\tsetUniformi: function(name, x, y, z, w) {\n\t\t'use strict';\n\t\tvar gl = this.gl;\n\t\tvar loc = this.getUniformLocation(name);\n\t\tif (loc === null)\n\t\t\treturn false;\n\t\tswitch (arguments.length) {\n\t\t\tcase 2: gl.uniform1i(loc, x); return true;\n\t\t\tcase 3: gl.uniform2i(loc, x, y); return true;\n\t\t\tcase 4: gl.uniform3i(loc, x, y, z); return true;\n\t\t\tcase 5: gl.uniform4i(loc, x, y, z, w); return true;\n\t\t\tdefault:\n\t\t\t\tthrow \"invalid arguments to setUniformi\"; \n\t\t}\n\t},\n\n\t/**\n\t * A convenience method to set uniformf from the given arguments.\n\t * We determine which GL call to make based on the number of arguments\n\t * passed. For example, `setUniformf(\"var\", 0, 1)` maps to `gl.uniform2f`.\n\t * \n\t * @method  setUniformf\n\t * @param {String} name        \t\tthe name of the uniform\n\t * @param {GLfloat} x  the x component for floats\n\t * @param {GLfloat} y  the y component for vec2\n\t * @param {GLfloat} z  the z component for vec3\n\t * @param {GLfloat} w  the w component for vec4\n\t */\n\tsetUniformf: function(name, x, y, z, w) {\n\t\t'use strict';\n\t\tvar gl = this.gl;\n\t\tvar loc = this.getUniformLocation(name);\n\t\tif (loc === null)\n\t\t\treturn false;\n\t\tswitch (arguments.length) {\n\t\t\tcase 2: gl.uniform1f(loc, x); return true;\n\t\t\tcase 3: gl.uniform2f(loc, x, y); return true;\n\t\t\tcase 4: gl.uniform3f(loc, x, y, z); return true;\n\t\t\tcase 5: gl.uniform4f(loc, x, y, z, w); return true;\n\t\t\tdefault:\n\t\t\t\tthrow \"invalid arguments to setUniformf\"; \n\t\t}\n\t},\n\n\t//I guess we won't support sequence<GLfloat> .. whatever that is ??\n\t\n\n\t///// \n\t\n\t/**\n\t * A convenience method to set uniformNfv from the given ArrayBuffer.\n\t * We determine which GL call to make based on the length of the array \n\t * buffer (for 1-4 component vectors stored in a Float32Array). To use\n\t * this method to upload data to uniform arrays, you need to specify the\n\t * 'count' parameter; i.e. the data type you are using for that array. If\n\t * specified, this will dictate whether to call uniform1fv, uniform2fv, etc.\n\t *\n\t * @method  setUniformfv\n\t * @param {String} name        \t\tthe name of the uniform\n\t * @param {ArrayBuffer} arrayBuffer the array buffer\n\t * @param {Number} count            optional, the explicit data type count, e.g. 2 for vec2\n\t */\n\tsetUniformfv: function(name, arrayBuffer, count) {\n\t\t'use strict';\n\t\tcount = count || arrayBuffer.length;\n\t\tvar gl = this.gl;\n\t\tvar loc = this.getUniformLocation(name);\n\t\tif (loc === null)\n\t\t\treturn false;\n\t\tswitch (count) {\n\t\t\tcase 1: gl.uniform1fv(loc, arrayBuffer); return true;\n\t\t\tcase 2: gl.uniform2fv(loc, arrayBuffer); return true;\n\t\t\tcase 3: gl.uniform3fv(loc, arrayBuffer); return true;\n\t\t\tcase 4: gl.uniform4fv(loc, arrayBuffer); return true;\n\t\t\tdefault:\n\t\t\t\tthrow \"invalid arguments to setUniformf\"; \n\t\t}\n\t},\n\n\t/**\n\t * A convenience method to set uniformNiv from the given ArrayBuffer.\n\t * We determine which GL call to make based on the length of the array \n\t * buffer (for 1-4 component vectors stored in a int array). To use\n\t * this method to upload data to uniform arrays, you need to specify the\n\t * 'count' parameter; i.e. the data type you are using for that array. If\n\t * specified, this will dictate whether to call uniform1fv, uniform2fv, etc.\n\t *\n\t * @method  setUniformiv\n\t * @param {String} name        \t\tthe name of the uniform\n\t * @param {ArrayBuffer} arrayBuffer the array buffer\n\t * @param {Number} count            optional, the explicit data type count, e.g. 2 for ivec2\n\t */\n\tsetUniformiv: function(name, arrayBuffer, count) {\n\t\t'use strict';\n\t\tcount = count || arrayBuffer.length;\n\t\tvar gl = this.gl;\n\t\tvar loc = this.getUniformLocation(name);\n\t\tif (loc === null)\n\t\t\treturn false;\n\t\tswitch (count) {\n\t\t\tcase 1: gl.uniform1iv(loc, arrayBuffer); return true;\n\t\t\tcase 2: gl.uniform2iv(loc, arrayBuffer); return true;\n\t\t\tcase 3: gl.uniform3iv(loc, arrayBuffer); return true;\n\t\t\tcase 4: gl.uniform4iv(loc, arrayBuffer); return true;\n\t\t\tdefault:\n\t\t\t\tthrow \"invalid arguments to setUniformf\"; \n\t\t}\n\t},\n\n\t/**\n\t * This is a convenience function to pass a Matrix3 (from vecmath,\n\t * kami's preferred math library) or a Float32Array (e.g. gl-matrix)\n\t * to a shader. If mat is an object with \"val\", it is considered to be\n\t * a Matrix3, otherwise assumed to be a typed array being passed directly\n\t * to the shader.\n\t * \n\t * @param {String} name the uniform name\n\t * @param {Matrix3|Float32Array} mat a Matrix3 or Float32Array\n\t * @param {Boolean} transpose whether to transpose the matrix, default false\n\t */\n\tsetUniformMatrix3: function(name, mat, transpose) {\n\t\t'use strict';\n\t\tvar arr = typeof mat === \"object\" && mat.val ? mat.val : mat;\n\t\ttranspose = !!transpose; //to boolean\n\n\t\tvar gl = this.gl;\n\t\tvar loc = this.getUniformLocation(name);\n\t\tif (loc === null)\n\t\t\treturn false;\n\t\tgl.uniformMatrix3fv(loc, transpose, arr)\n\t},\n\n\t/**\n\t * This is a convenience function to pass a Matrix4 (from vecmath,\n\t * kami's preferred math library) or a Float32Array (e.g. gl-matrix)\n\t * to a shader. If mat is an object with \"val\", it is considered to be\n\t * a Matrix4, otherwise assumed to be a typed array being passed directly\n\t * to the shader.\n\t * \n\t * @param {String} name the uniform name\n\t * @param {Matrix4|Float32Array} mat a Matrix4 or Float32Array\n\t * @param {Boolean} transpose whether to transpose the matrix, default false\n\t */\n\tsetUniformMatrix4: function(name, mat, transpose) {\n\t\t'use strict';\n\t\tvar arr = typeof mat === \"object\" && mat.val ? mat.val : mat;\n\t\ttranspose = !!transpose; //to boolean\n\n\t\tvar gl = this.gl;\n\t\tvar loc = this.getUniformLocation(name);\n\t\tif (loc === null)\n\t\t\treturn false;\n\t\tgl.uniformMatrix4fv(loc, transpose, arr)\n\t} \n \n});\n\n//Some default attribute names that parts of kami will use\n//when creating a standard shader.\nShaderProgram.POSITION_ATTRIBUTE = \"Position\";\nShaderProgram.NORMAL_ATTRIBUTE = \"Normal\";\nShaderProgram.COLOR_ATTRIBUTE = \"Color\";\nShaderProgram.TEXCOORD_ATTRIBUTE = \"TexCoord\";\n\n/**\n * Whether to include verbose warnings during shader compilation.\n * This includes:\n *\n *   - Printing full shaders (with line numbers) when there is an error\n *   - Printing warnings even if the shader compiled successfully \n *   \n * @property {Boolean} VERBOSE_COMPILE\n */\nShaderProgram.VERBOSE_COMPILE = true;\n\nmodule.exports = ShaderProgram;"]},"metadata":{},"sourceType":"script"}