{"ast":null,"code":"/**\n * A mesh class that wraps VBO and IBO. Mostly used internally.\n * \n * @module kami-mesh-buffer\n */\nvar Class = require('klasse');\n\nvar BaseObject = require('kami-util').BaseObject; //TODO: decouple into VBO + IBO utilities \n\n/**\n * \n *\n * @class  Mesh\n */\n\n\nvar Mesh = new Class({\n  /**\n   * A write-only property which sets both vertices and indices \n   * flag to dirty or not. \n   *\n   * @property dirty\n   * @type {Boolean}\n   * @writeOnly\n   */\n  dirty: {\n    set: function set(val) {\n      this.verticesDirty = val;\n      this.indicesDirty = val;\n    }\n  },\n\n  /**\n   * Creates a new Mesh with the provided parameters.\n   *\n   * If numIndices is 0 or falsy, no index buffer will be used\n   * and indices will be an empty ArrayBuffer and a null indexBuffer.\n   * \n   * If isStatic is true, then vertexUsage and indexUsage will\n   * be set to gl.STATIC_DRAW. Otherwise they will use gl.DYNAMIC_DRAW.\n   * You may want to adjust these after initialization for further control.\n   * \n   * @param  {WebGLContext}  context the context for management\n   * @param  {Boolean} isStatic      a hint as to whether this geometry is static\n   * @param  {[type]}  numVerts      [description]\n   * @param  {[type]}  numIndices    [description]\n   * @param  {[type]}  vertexAttribs [description]\n   * @return {[type]}                [description]\n   */\n  initialize: function Mesh(context, isStatic, numVerts, numIndices, vertexAttribs) {\n    //TODO: use options here...\n    if (!numVerts) throw \"numVerts not specified, must be > 0\";\n    BaseObject.call(this, context);\n    this.gl = this.context.gl;\n    this.numVerts = null;\n    this.numIndices = null;\n    this.vertices = null;\n    this.indices = null;\n    this.vertexBuffer = null;\n    this.indexBuffer = null;\n    this.verticesDirty = true;\n    this.indicesDirty = true;\n    this.indexUsage = null;\n    this.vertexUsage = null;\n    /** \n     * @property\n     * @private\n     */\n\n    this._vertexAttribs = null;\n    /** \n     * The stride for one vertex _in bytes_. \n     * \n     * @property {Number} vertexStride\n     */\n\n    this.vertexStride = null;\n    this.numVerts = numVerts;\n    this.numIndices = numIndices || 0;\n    this.vertexUsage = isStatic ? this.gl.STATIC_DRAW : this.gl.DYNAMIC_DRAW;\n    this.indexUsage = isStatic ? this.gl.STATIC_DRAW : this.gl.DYNAMIC_DRAW;\n    this._vertexAttribs = vertexAttribs || [];\n    this.indicesDirty = true;\n    this.verticesDirty = true; //determine the vertex stride based on given attributes\n\n    var totalNumComponents = 0;\n\n    for (var i = 0; i < this._vertexAttribs.length; i++) {\n      totalNumComponents += this._vertexAttribs[i].offsetCount;\n    }\n\n    this.vertexStride = totalNumComponents * 4; // in bytes\n\n    this.vertices = new Float32Array(this.numVerts);\n    this.indices = new Uint16Array(this.numIndices); //add this VBO to the managed cache\n\n    this.context.addManagedObject(this);\n    this.create();\n  },\n  //recreates the buffers on context loss\n  create: function create() {\n    this.gl = this.context.gl;\n    var gl = this.gl;\n    this.vertexBuffer = gl.createBuffer(); //ignore index buffer if we haven't specified any\n\n    this.indexBuffer = this.numIndices > 0 ? gl.createBuffer() : null;\n    this.dirty = true;\n  },\n  destroy: function destroy() {\n    this.vertices = null;\n    this.indices = null;\n    if (this.vertexBuffer && this.gl) this.gl.deleteBuffer(this.vertexBuffer);\n    if (this.indexBuffer && this.gl) this.gl.deleteBuffer(this.indexBuffer);\n    this.vertexBuffer = null;\n    this.indexBuffer = null;\n    if (this.context) this.context.removeManagedObject(this);\n    this.gl = null;\n    this.context = null;\n  },\n  _updateBuffers: function _updateBuffers(ignoreBind, subDataLength) {\n    var gl = this.gl; //bind our index data, if we have any\n\n    if (this.numIndices > 0) {\n      if (!ignoreBind) gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer); //update the index data\n\n      if (this.indicesDirty) {\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, this.indexUsage);\n        this.indicesDirty = false;\n      }\n    } //bind our vertex data\n\n\n    if (!ignoreBind) gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer); //update our vertex data\n\n    if (this.verticesDirty) {\n      if (subDataLength) {\n        // TODO: When decoupling VBO/IBO be sure to give better subData support..\n        var view = this.vertices.subarray(0, subDataLength);\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\n      } else {\n        gl.bufferData(gl.ARRAY_BUFFER, this.vertices, this.vertexUsage);\n      }\n\n      this.verticesDirty = false;\n    }\n  },\n  draw: function draw(primitiveType, count, offset, subDataLength) {\n    if (count === 0) return;\n    var gl = this.gl;\n    offset = offset || 0; //binds and updates our buffers. pass ignoreBind as true\n    //to avoid binding unnecessarily\n\n    this._updateBuffers(true, subDataLength);\n\n    if (this.numIndices > 0) {\n      gl.drawElements(primitiveType, count, gl.UNSIGNED_SHORT, offset * 2); //* Uint16Array.BYTES_PER_ELEMENT\n    } else gl.drawArrays(primitiveType, offset, count);\n  },\n  //binds this mesh's vertex attributes for the given shader\n  bind: function bind(shader) {\n    var gl = this.gl;\n    var offset = 0;\n    var stride = this.vertexStride; //bind and update our vertex data before binding attributes\n\n    this._updateBuffers(); //for each attribtue\n\n\n    for (var i = 0; i < this._vertexAttribs.length; i++) {\n      var a = this._vertexAttribs[i]; //location of the attribute\n\n      var loc = a.location === null ? shader.getAttributeLocation(a.name) : a.location; //TODO: We may want to skip unfound attribs\n      // if (loc!==0 && !loc)\n      // \tconsole.warn(\"WARN:\", a.name, \"is not enabled\");\n      //first, enable the vertex array\n\n      gl.enableVertexAttribArray(loc); //then specify our vertex format\n\n      gl.vertexAttribPointer(loc, a.numComponents, a.type || gl.FLOAT, a.normalize, stride, offset); //and increase the offset...\n\n      offset += a.offsetCount * 4; //in bytes\n    }\n  },\n  unbind: function unbind(shader) {\n    var gl = this.gl; //for each attribtue\n\n    for (var i = 0; i < this._vertexAttribs.length; i++) {\n      var a = this._vertexAttribs[i]; //location of the attribute\n\n      var loc = a.location === null ? shader.getAttributeLocation(a.name) : a.location; //first, enable the vertex array\n\n      gl.disableVertexAttribArray(loc);\n    }\n  }\n});\nMesh.Attrib = new Class({\n  name: null,\n  numComponents: null,\n  location: null,\n  type: null,\n\n  /**\n   * Mesh vertex attribute holder.\n   * \n   * Location is optional and for advanced users that\n   * want vertex arrays to match across shaders. Any non-numerical\n   * value will be converted to null, and ignored. If a numerical\n   * value is given, it will override the position of this attribute\n   * when given to a mesh.\n   *\n   * @class  Mesh.Attrib\n   * @constructor\n   * @param {String} name the name of the attribute\n   * @param {Number} numComponents the number of components, e.g. 2 for vec2\n   * @param {Number} location optional attribute index location\n   * @param {Number} type defaults to GL_FLOAT \n   * @param {Number} normalize whether to normalize to 0-1, default false\n   */\n  initialize: function initialize(name, numComponents, location, type, normalize, offsetCount) {\n    this.name = name;\n    this.numComponents = numComponents;\n    this.location = typeof location === \"number\" ? location : null;\n    this.type = type;\n    this.normalize = Boolean(normalize);\n    this.offsetCount = typeof offsetCount === \"number\" ? offsetCount : this.numComponents;\n  }\n});\nmodule.exports = Mesh;","map":{"version":3,"sources":["E:/fcatcher-client/node_modules/kami-mesh-buffer/index.js"],"names":["Class","require","BaseObject","Mesh","dirty","set","val","verticesDirty","indicesDirty","initialize","context","isStatic","numVerts","numIndices","vertexAttribs","call","gl","vertices","indices","vertexBuffer","indexBuffer","indexUsage","vertexUsage","_vertexAttribs","vertexStride","STATIC_DRAW","DYNAMIC_DRAW","totalNumComponents","i","length","offsetCount","Float32Array","Uint16Array","addManagedObject","create","createBuffer","destroy","deleteBuffer","removeManagedObject","_updateBuffers","ignoreBind","subDataLength","bindBuffer","ELEMENT_ARRAY_BUFFER","bufferData","ARRAY_BUFFER","view","subarray","bufferSubData","draw","primitiveType","count","offset","drawElements","UNSIGNED_SHORT","drawArrays","bind","shader","stride","a","loc","location","getAttributeLocation","name","enableVertexAttribArray","vertexAttribPointer","numComponents","type","FLOAT","normalize","unbind","disableVertexAttribArray","Attrib","Boolean","module","exports"],"mappings":"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","sourcesContent":["/**\n * A mesh class that wraps VBO and IBO. Mostly used internally.\n * \n * @module kami-mesh-buffer\n */\n\nvar Class = require('klasse');\nvar BaseObject = require('kami-util').BaseObject;\n\n//TODO: decouple into VBO + IBO utilities \n/**\n * \n *\n * @class  Mesh\n */\nvar Mesh = new Class({\n\n\n\t/**\n\t * A write-only property which sets both vertices and indices \n\t * flag to dirty or not. \n\t *\n\t * @property dirty\n\t * @type {Boolean}\n\t * @writeOnly\n\t */\n\tdirty: {\n\t\tset: function(val) {\n\t\t\tthis.verticesDirty = val;\n\t\t\tthis.indicesDirty = val;\n\t\t}\n\t},\n\n\t/**\n\t * Creates a new Mesh with the provided parameters.\n\t *\n\t * If numIndices is 0 or falsy, no index buffer will be used\n\t * and indices will be an empty ArrayBuffer and a null indexBuffer.\n\t * \n\t * If isStatic is true, then vertexUsage and indexUsage will\n\t * be set to gl.STATIC_DRAW. Otherwise they will use gl.DYNAMIC_DRAW.\n\t * You may want to adjust these after initialization for further control.\n\t * \n\t * @param  {WebGLContext}  context the context for management\n\t * @param  {Boolean} isStatic      a hint as to whether this geometry is static\n\t * @param  {[type]}  numVerts      [description]\n\t * @param  {[type]}  numIndices    [description]\n\t * @param  {[type]}  vertexAttribs [description]\n\t * @return {[type]}                [description]\n\t */\n\tinitialize: function Mesh(context, isStatic, numVerts, numIndices, vertexAttribs) {\n\t\t//TODO: use options here...\n\t\tif (!numVerts)\n\t\t\tthrow \"numVerts not specified, must be > 0\";\n\n\t\tBaseObject.call(this, context);\n\n\t\tthis.gl = this.context.gl;\n\t\t\n\t\tthis.numVerts = null;\n\t\tthis.numIndices = null;\n\t\t\n\t\tthis.vertices = null;\n\t\tthis.indices = null;\n\t\tthis.vertexBuffer = null;\n\t\tthis.indexBuffer = null;\n\n\t\tthis.verticesDirty = true;\n\t\tthis.indicesDirty = true;\n\t\tthis.indexUsage = null;\n\t\tthis.vertexUsage = null;\n\n\t\t/** \n\t\t * @property\n\t\t * @private\n\t\t */\n\t\tthis._vertexAttribs = null;\n\n\t\t/** \n\t\t * The stride for one vertex _in bytes_. \n\t\t * \n\t\t * @property {Number} vertexStride\n\t\t */\n\t\tthis.vertexStride = null;\n\n\t\tthis.numVerts = numVerts;\n\t\tthis.numIndices = numIndices || 0;\n\t\tthis.vertexUsage = isStatic ? this.gl.STATIC_DRAW : this.gl.DYNAMIC_DRAW;\n\t\tthis.indexUsage  = isStatic ? this.gl.STATIC_DRAW : this.gl.DYNAMIC_DRAW;\n\t\tthis._vertexAttribs = vertexAttribs || [];\n\t\t\n\t\tthis.indicesDirty = true;\n\t\tthis.verticesDirty = true;\n\n\t\t//determine the vertex stride based on given attributes\n\t\tvar totalNumComponents = 0;\n\t\tfor (var i=0; i<this._vertexAttribs.length; i++)\n\t\t\ttotalNumComponents += this._vertexAttribs[i].offsetCount;\n\t\tthis.vertexStride = totalNumComponents * 4; // in bytes\n\n\t\tthis.vertices = new Float32Array(this.numVerts);\n\t\tthis.indices = new Uint16Array(this.numIndices);\n\n\t\t//add this VBO to the managed cache\n\t\tthis.context.addManagedObject(this);\n\n\t\tthis.create();\n\t},\n\n\t//recreates the buffers on context loss\n\tcreate: function() {\n\t\tthis.gl = this.context.gl;\n\t\tvar gl = this.gl;\n\t\tthis.vertexBuffer = gl.createBuffer();\n\n\t\t//ignore index buffer if we haven't specified any\n\t\tthis.indexBuffer = this.numIndices > 0\n\t\t\t\t\t? gl.createBuffer()\n\t\t\t\t\t: null;\n\n\t\tthis.dirty = true;\n\t},\n\n\tdestroy: function() {\n\t\tthis.vertices = null;\n\t\tthis.indices = null;\n\t\tif (this.vertexBuffer && this.gl)\n\t\t\tthis.gl.deleteBuffer(this.vertexBuffer);\n\t\tif (this.indexBuffer && this.gl)\n\t\t\tthis.gl.deleteBuffer(this.indexBuffer);\n\t\tthis.vertexBuffer = null;\n\t\tthis.indexBuffer = null;\n\t\tif (this.context)\n\t\t\tthis.context.removeManagedObject(this);\n\t\tthis.gl = null;\n\t\tthis.context = null;\n\t},\n\n\t_updateBuffers: function(ignoreBind, subDataLength) {\n\t\tvar gl = this.gl;\n\n\t\t//bind our index data, if we have any\n\t\tif (this.numIndices > 0) {\n\t\t\tif (!ignoreBind)\n\t\t\t\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n\t\t\t//update the index data\n\t\t\tif (this.indicesDirty) {\n\t\t\t\tgl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, this.indexUsage);\n\t\t\t\tthis.indicesDirty = false;\n\t\t\t}\n\t\t}\n\n\t\t//bind our vertex data\n\t\tif (!ignoreBind)\n\t\t\tgl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n\n\t\t//update our vertex data\n\t\tif (this.verticesDirty) {\n\t\t\tif (subDataLength) {\n\t\t\t\t// TODO: When decoupling VBO/IBO be sure to give better subData support..\n\t\t\t\tvar view = this.vertices.subarray(0, subDataLength);\n\t\t\t\tgl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\n\t\t\t} else {\n\t\t\t\tgl.bufferData(gl.ARRAY_BUFFER, this.vertices, this.vertexUsage);\t\n\t\t\t}\n\n\t\t\t\n\t\t\tthis.verticesDirty = false;\n\t\t}\n\t},\n\n\tdraw: function(primitiveType, count, offset, subDataLength) {\n\t\tif (count === 0)\n\t\t\treturn;\n\n\t\tvar gl = this.gl;\n\t\t\n\t\toffset = offset || 0;\n\n\t\t//binds and updates our buffers. pass ignoreBind as true\n\t\t//to avoid binding unnecessarily\n\t\tthis._updateBuffers(true, subDataLength);\n\n\t\tif (this.numIndices > 0) { \n\t\t\tgl.drawElements(primitiveType, count, \n\t\t\t\t\t\tgl.UNSIGNED_SHORT, offset * 2); //* Uint16Array.BYTES_PER_ELEMENT\n\t\t} else\n\t\t\tgl.drawArrays(primitiveType, offset, count);\n\t},\n\n\t//binds this mesh's vertex attributes for the given shader\n\tbind: function(shader) {\n\t\tvar gl = this.gl;\n\n\t\tvar offset = 0;\n\t\tvar stride = this.vertexStride;\n\n\t\t//bind and update our vertex data before binding attributes\n\t\tthis._updateBuffers();\n\n\t\t//for each attribtue\n\t\tfor (var i=0; i<this._vertexAttribs.length; i++) {\n\t\t\tvar a = this._vertexAttribs[i];\n\n\t\t\t//location of the attribute\n\t\t\tvar loc = a.location === null \n\t\t\t\t\t? shader.getAttributeLocation(a.name)\n\t\t\t\t\t: a.location;\n\n\t\t\t//TODO: We may want to skip unfound attribs\n\t\t\t// if (loc!==0 && !loc)\n\t\t\t// \tconsole.warn(\"WARN:\", a.name, \"is not enabled\");\n\n\t\t\t//first, enable the vertex array\n\t\t\tgl.enableVertexAttribArray(loc);\n\n\t\t\t//then specify our vertex format\n\t\t\tgl.vertexAttribPointer(loc, a.numComponents, a.type || gl.FLOAT, \n\t\t\t\t\t\t\t\t   a.normalize, stride, offset);\n\n\t\t\t//and increase the offset...\n\t\t\toffset += a.offsetCount * 4; //in bytes\n\t\t}\n\t},\n\n\tunbind: function(shader) {\n\t\tvar gl = this.gl;\n\n\t\t//for each attribtue\n\t\tfor (var i=0; i<this._vertexAttribs.length; i++) {\n\t\t\tvar a = this._vertexAttribs[i];\n\n\t\t\t//location of the attribute\n\t\t\tvar loc = a.location === null \n\t\t\t\t\t? shader.getAttributeLocation(a.name)\n\t\t\t\t\t: a.location;\n\n\t\t\t//first, enable the vertex array\n\t\t\tgl.disableVertexAttribArray(loc);\n\t\t}\n\t}\n});\n\nMesh.Attrib = new Class({\n\n\tname: null,\n\tnumComponents: null,\n\tlocation: null,\n\ttype: null,\n\n\t/**\n\t * Mesh vertex attribute holder.\n\t * \n\t * Location is optional and for advanced users that\n\t * want vertex arrays to match across shaders. Any non-numerical\n\t * value will be converted to null, and ignored. If a numerical\n\t * value is given, it will override the position of this attribute\n\t * when given to a mesh.\n\t *\n\t * @class  Mesh.Attrib\n\t * @constructor\n\t * @param {String} name the name of the attribute\n\t * @param {Number} numComponents the number of components, e.g. 2 for vec2\n\t * @param {Number} location optional attribute index location\n\t * @param {Number} type defaults to GL_FLOAT \n\t * @param {Number} normalize whether to normalize to 0-1, default false\n\t */\n\tinitialize: function(name, numComponents, location, type, normalize, offsetCount) {\n\t\tthis.name = name;\n\t\tthis.numComponents = numComponents;\n\t\tthis.location = typeof location === \"number\" ? location : null;\n\t\tthis.type = type;\n\t\tthis.normalize = Boolean(normalize);\n\t\tthis.offsetCount = typeof offsetCount === \"number\" ? offsetCount : this.numComponents;\n\t}\n});\n\n\nmodule.exports = Mesh;"]},"metadata":{},"sourceType":"script"}