{"ast":null,"code":"/**\n * An abstract batcher for dynamic geometry. This handles\n * the basics, like setting blend functions, color, and so forth.\n * \n * @module kami-base-batch\n */\nvar Class = require('klasse');\n\nvar Mesh = require('kami-mesh-buffer');\n\nvar BaseObject = require('kami-util').BaseObject;\n\nvar colorToFloat = require('number-util').colorToFloat;\n\nvar BaseMixins = require('./mixins');\n/** \n * A batcher, typically used for quads (2 tris, indexed), but may\n * also be used for other dynamic types of geometry. This is generally\n * not static; the vertex buffers are using DYNAMIC_DRAW for performance.\n * \n * This is used internally; users should look at \n * {{#crossLink \"SpriteBatch\"}}{{/crossLink}} instead, which inherits from this\n * class. \n * \n * The batcher itself is not managed by WebGLContext; however, it makes\n * use of Mesh and Texture which will be managed. For this reason, the batcher\n * does not hold a direct reference to the GL state.\n *\n * Subclasses must implement the following:  \n * {{#crossLink \"BaseBatch/_createShader:method\"}}{{/crossLink}}  \n * {{#crossLink \"BaseBatch/_createVertexAttributes:method\"}}{{/crossLink}}  \n * {{#crossLink \"BaseBatch/getVertexSize:method\"}}{{/crossLink}}  \n * \n * @class BaseBatch\n * @protected\n * @abstract\n * \n * @constructor\n * @param {WebGLContext} context the context this batcher belongs to\n * @param {Object} options the options\n * @param {Number} options.size the optional size of this batch, i.e. max number of quads\n * @default  500\n */\n\n\nvar BaseBatch = new Class({\n  Mixins: BaseMixins,\n  //Constructor\n  initialize: function BaseBatch(context, options) {\n    BaseObject.call(this, context);\n    options = options || {};\n\n    var shader = this._createShader();\n\n    this.idx = 0;\n    this.mesh = this._createMesh(options.size); //set up the properties for our base batch...\n\n    BaseMixins.call(this, this.context.gl, shader);\n  },\n\n  /**\n   * Called from the constructor to create a new Mesh \n   * based on the expected batch size. Should set up\n   * verts & indices properly.\n   *\n   * Users should not call this directly; instead, it\n   * should only be implemented by subclasses.\n   * \n   * @method _createMesh\n   * @param {Number} size the size passed through the constructor\n   */\n  _createMesh: function _createMesh(size) {\n    size = size || 500; // 65535 is max index, so 65535 / 6 = 10922.\n\n    if (size > 10922) throw \"Can't have more than 10922 sprites per batch: \" + size; //the total number of floats in our batch\n\n    var numVerts = size * 4 * this.getVertexSize(); //the total number of indices in our batch\n\n    var numIndices = size * 6;\n    var gl = this.context.gl; //vertex data\n\n    this.vertices = new Float32Array(numVerts); //index data\n\n    this.indices = new Uint16Array(numIndices);\n\n    for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {\n      this.indices[i + 0] = j + 0;\n      this.indices[i + 1] = j + 1;\n      this.indices[i + 2] = j + 2;\n      this.indices[i + 3] = j + 0;\n      this.indices[i + 4] = j + 2;\n      this.indices[i + 5] = j + 3;\n    }\n\n    var mesh = new Mesh(this.context, false, numVerts, numIndices, this._createVertexAttributes());\n    mesh.vertices = this.vertices;\n    mesh.indices = this.indices;\n    mesh.vertexUsage = gl.DYNAMIC_DRAW;\n    mesh.indexUsage = gl.STATIC_DRAW;\n    mesh.dirty = true;\n    return mesh;\n  },\n\n  /**\n   * Returns a shader for this batch. If you plan to support\n   * multiple instances of your batch, it may or may not be wise\n   * to use a shared shader to save resources.\n   * \n   * This method initially throws an error; so it must be overridden by\n   * subclasses of BaseBatch.\n   *\n   * @method  _createShader\n   * @return {Number} the size of a vertex, in # of floats\n   */\n  _createShader: function _createShader() {\n    throw \"_createShader not implemented\";\n  },\n\n  /**\n   * Returns an array of vertex attributes for this mesh; \n   * subclasses should implement this with the attributes \n   * expected for their batch.\n   *\n   * This method initially throws an error; so it must be overridden by\n   * subclasses of BaseBatch.\n   *\n   * @method _createVertexAttributes\n   * @return {Array} an array of Mesh.VertexAttrib objects\n   */\n  _createVertexAttributes: function _createVertexAttributes() {\n    throw \"_createVertexAttributes not implemented\";\n  },\n\n  /**\n   * Returns the number of floats per vertex for this batcher.\n   * \n   * This method initially throws an error; so it must be overridden by\n   * subclasses of BaseBatch.\n   *\n   * @method  getVertexSize\n   * @return {Number} the size of a vertex, in # of floats\n   */\n  getVertexSize: function getVertexSize() {\n    throw \"getVertexSize not implemented\";\n  },\n\n  /** \n   * Begins the sprite batch. This will bind the shader\n   * and mesh. Subclasses may want to disable depth or \n   * set up blending.\n   *\n   * @method  begin\n   */\n  begin: function begin() {\n    if (this.drawing) throw \"batch.end() must be called before begin\";\n    this.drawing = true;\n    this.shader.bind(); //bind the attributes now to avoid redundant calls\n\n    this.mesh.bind(this.shader);\n\n    if (this._blendingEnabled) {\n      var gl = this.context.gl;\n      gl.enable(gl.BLEND);\n    }\n  },\n\n  /** \n   * Ends the sprite batch. This will flush any remaining \n   * data and set GL state back to normal.\n   * \n   * @method  end\n   */\n  end: function end() {\n    if (!this.drawing) throw \"batch.begin() must be called before end\";\n    if (this.idx > 0) this.flush();\n    this.drawing = false;\n    this.mesh.unbind(this.shader);\n\n    if (this._blendingEnabled) {\n      var gl = this.context.gl;\n      gl.disable(gl.BLEND);\n    }\n  },\n\n  /** \n   * Called before rendering to bind new textures.\n   * This method does nothing by default.\n   *\n   * @method  _preRender\n   */\n  _preRender: function _preRender() {},\n\n  /**\n   * Flushes the batch by pushing the current data\n   * to GL.\n   * \n   * @method flush\n   */\n  flush: function flush() {\n    if (this.idx === 0) return;\n    var gl = this.context.gl; //premultiplied alpha\n\n    if (this._blendingEnabled) {\n      //set either to null if you want to call your own \n      //blendFunc or blendFuncSeparate\n      if (this._blendSrc && this._blendDst) gl.blendFunc(this._blendSrc, this._blendDst);\n    }\n\n    this._preRender(); //number of sprites in batch\n\n\n    var numComponents = this.getVertexSize();\n    var spriteCount = this.idx / (numComponents * 4); //draw the sprites\n\n    this.mesh.verticesDirty = true;\n    this.mesh.draw(gl.TRIANGLES, spriteCount * 6, 0, this.idx);\n    this.idx = 0;\n  },\n\n  /**\n   * Destroys the batch, deleting its buffers and removing it from the\n   * WebGLContext management. Trying to use this\n   * batch after destroying it can lead to unpredictable behaviour.\n   *\n   * If `ownsShader` is true, this will also delete the `defaultShader` object.\n   * \n   * @method destroy\n   */\n  destroy: function destroy() {\n    this.vertices = null;\n    this.indices = null;\n    this.maxVertices = 0;\n    if (this.ownsShader && this.defaultShader) this.defaultShader.destroy();\n    this.defaultShader = null;\n    this._shader = null; // remove reference to whatever shader is currently being used\n\n    if (this.mesh) this.mesh.destroy();\n    this.mesh = null;\n  }\n});\nmodule.exports = BaseBatch;","map":{"version":3,"sources":["E:/fcatcher-client/node_modules/kami-base-batch/index.js"],"names":["Class","require","Mesh","BaseObject","colorToFloat","BaseMixins","BaseBatch","Mixins","initialize","context","options","call","shader","_createShader","idx","mesh","_createMesh","size","gl","numVerts","getVertexSize","numIndices","vertices","Float32Array","indices","Uint16Array","i","j","_createVertexAttributes","vertexUsage","DYNAMIC_DRAW","indexUsage","STATIC_DRAW","dirty","begin","drawing","bind","_blendingEnabled","enable","BLEND","end","flush","unbind","disable","_preRender","_blendSrc","_blendDst","blendFunc","numComponents","spriteCount","verticesDirty","draw","TRIANGLES","destroy","maxVertices","ownsShader","defaultShader","_shader","module","exports"],"mappings":"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","sourcesContent":["/**\n * An abstract batcher for dynamic geometry. This handles\n * the basics, like setting blend functions, color, and so forth.\n * \n * @module kami-base-batch\n */\n\nvar Class = require('klasse');\nvar Mesh = require('kami-mesh-buffer');\nvar BaseObject = require('kami-util').BaseObject;\n\nvar colorToFloat = require('number-util').colorToFloat;\n\nvar BaseMixins = require('./mixins');\n\n/** \n * A batcher, typically used for quads (2 tris, indexed), but may\n * also be used for other dynamic types of geometry. This is generally\n * not static; the vertex buffers are using DYNAMIC_DRAW for performance.\n * \n * This is used internally; users should look at \n * {{#crossLink \"SpriteBatch\"}}{{/crossLink}} instead, which inherits from this\n * class. \n * \n * The batcher itself is not managed by WebGLContext; however, it makes\n * use of Mesh and Texture which will be managed. For this reason, the batcher\n * does not hold a direct reference to the GL state.\n *\n * Subclasses must implement the following:  \n * {{#crossLink \"BaseBatch/_createShader:method\"}}{{/crossLink}}  \n * {{#crossLink \"BaseBatch/_createVertexAttributes:method\"}}{{/crossLink}}  \n * {{#crossLink \"BaseBatch/getVertexSize:method\"}}{{/crossLink}}  \n * \n * @class BaseBatch\n * @protected\n * @abstract\n * \n * @constructor\n * @param {WebGLContext} context the context this batcher belongs to\n * @param {Object} options the options\n * @param {Number} options.size the optional size of this batch, i.e. max number of quads\n * @default  500\n */\nvar BaseBatch = new Class({\n\n\tMixins: BaseMixins,\n\n\t//Constructor\n\tinitialize: function BaseBatch(context, options) {\n\t\tBaseObject.call(this, context);\n\t\toptions = options||{};\n\n\t\tvar shader = this._createShader();\n\t\t\n\t\tthis.idx = 0;\n\n\t\tthis.mesh = this._createMesh(options.size);\n\n\t\t//set up the properties for our base batch...\n\t\tBaseMixins.call(this, this.context.gl, shader);\n\t},\n\n\t/**\n\t * Called from the constructor to create a new Mesh \n\t * based on the expected batch size. Should set up\n\t * verts & indices properly.\n\t *\n\t * Users should not call this directly; instead, it\n\t * should only be implemented by subclasses.\n\t * \n\t * @method _createMesh\n\t * @param {Number} size the size passed through the constructor\n\t */\n\t_createMesh: function(size) {\n\t\tsize = size||500;\n\t\t// 65535 is max index, so 65535 / 6 = 10922.\n\t\tif (size > 10922)\n\t\t\tthrow \"Can't have more than 10922 sprites per batch: \" + size;\n\t\t\n\t\t//the total number of floats in our batch\n\t\tvar numVerts = size * 4 * this.getVertexSize();\n\t\t//the total number of indices in our batch\n\t\tvar numIndices = size * 6;\n\t\tvar gl = this.context.gl;\n\n\t\t//vertex data\n\t\tthis.vertices = new Float32Array(numVerts);\n\t\t//index data\n\t\tthis.indices = new Uint16Array(numIndices); \n\t\t\n\t\tfor (var i=0, j=0; i < numIndices; i += 6, j += 4) \n\t\t{\n\t\t\tthis.indices[i + 0] = j + 0; \n\t\t\tthis.indices[i + 1] = j + 1;\n\t\t\tthis.indices[i + 2] = j + 2;\n\t\t\tthis.indices[i + 3] = j + 0;\n\t\t\tthis.indices[i + 4] = j + 2;\n\t\t\tthis.indices[i + 5] = j + 3;\n\t\t}\n\n\t\tvar mesh = new Mesh(this.context, false, \n\t\t\t\t\t\tnumVerts, numIndices, this._createVertexAttributes());\n\t\tmesh.vertices = this.vertices;\n\t\tmesh.indices = this.indices;\n\t\tmesh.vertexUsage = gl.DYNAMIC_DRAW;\n\t\tmesh.indexUsage = gl.STATIC_DRAW;\n\t\tmesh.dirty = true;\n\t\treturn mesh;\n\t},\n\n\t/**\n\t * Returns a shader for this batch. If you plan to support\n\t * multiple instances of your batch, it may or may not be wise\n\t * to use a shared shader to save resources.\n\t * \n\t * This method initially throws an error; so it must be overridden by\n\t * subclasses of BaseBatch.\n\t *\n\t * @method  _createShader\n\t * @return {Number} the size of a vertex, in # of floats\n\t */\n\t_createShader: function() {\n\t\tthrow \"_createShader not implemented\"\n\t},\t\n\n\t/**\n\t * Returns an array of vertex attributes for this mesh; \n\t * subclasses should implement this with the attributes \n\t * expected for their batch.\n\t *\n\t * This method initially throws an error; so it must be overridden by\n\t * subclasses of BaseBatch.\n\t *\n\t * @method _createVertexAttributes\n\t * @return {Array} an array of Mesh.VertexAttrib objects\n\t */\n\t_createVertexAttributes: function() {\n\t\tthrow \"_createVertexAttributes not implemented\";\n\t},\n\n\n\t/**\n\t * Returns the number of floats per vertex for this batcher.\n\t * \n\t * This method initially throws an error; so it must be overridden by\n\t * subclasses of BaseBatch.\n\t *\n\t * @method  getVertexSize\n\t * @return {Number} the size of a vertex, in # of floats\n\t */\n\tgetVertexSize: function() {\n\t\tthrow \"getVertexSize not implemented\";\n\t},\n\n\t\n\t/** \n\t * Begins the sprite batch. This will bind the shader\n\t * and mesh. Subclasses may want to disable depth or \n\t * set up blending.\n\t *\n\t * @method  begin\n\t */\n\tbegin: function()  {\n\t\tif (this.drawing) \n\t\t\tthrow \"batch.end() must be called before begin\";\n\t\tthis.drawing = true;\n\n\t\tthis.shader.bind();\n\n\t\t//bind the attributes now to avoid redundant calls\n\t\tthis.mesh.bind(this.shader);\n\n\t\tif (this._blendingEnabled) {\n\t\t\tvar gl = this.context.gl;\n\t\t\tgl.enable(gl.BLEND);\n\t\t}\n\t},\n\n\t/** \n\t * Ends the sprite batch. This will flush any remaining \n\t * data and set GL state back to normal.\n\t * \n\t * @method  end\n\t */\n\tend: function()  {\n\t\tif (!this.drawing)\n\t\t\tthrow \"batch.begin() must be called before end\";\n\t\tif (this.idx > 0)\n\t\t\tthis.flush();\n\t\tthis.drawing = false;\n\n\t\tthis.mesh.unbind(this.shader);\n\n\t\tif (this._blendingEnabled) {\n\t\t\tvar gl = this.context.gl;\n\t\t\tgl.disable(gl.BLEND);\n\t\t}\n\t},\n\n\t/** \n\t * Called before rendering to bind new textures.\n\t * This method does nothing by default.\n\t *\n\t * @method  _preRender\n\t */\n\t_preRender: function()  {\n\t},\n\n\t/**\n\t * Flushes the batch by pushing the current data\n\t * to GL.\n\t * \n\t * @method flush\n\t */\n\tflush: function()  {\n\t\tif (this.idx===0)\n\t\t\treturn;\n\n\t\tvar gl = this.context.gl;\n\n\t\t//premultiplied alpha\n\t\tif (this._blendingEnabled) {\n\t\t\t//set either to null if you want to call your own \n\t\t\t//blendFunc or blendFuncSeparate\n\t\t\tif (this._blendSrc && this._blendDst)\n\t\t\t\tgl.blendFunc(this._blendSrc, this._blendDst); \n\t\t}\n\n\t\tthis._preRender();\n\n\t\t//number of sprites in batch\n\t\tvar numComponents = this.getVertexSize();\n\t\tvar spriteCount = (this.idx / (numComponents * 4));\n\t\t\n\t\t//draw the sprites\n\t\tthis.mesh.verticesDirty = true;\n\t\tthis.mesh.draw(gl.TRIANGLES, spriteCount * 6, 0, this.idx);\n\n\t\tthis.idx = 0;\n\t},\n\n\t/**\n\t * Destroys the batch, deleting its buffers and removing it from the\n\t * WebGLContext management. Trying to use this\n\t * batch after destroying it can lead to unpredictable behaviour.\n\t *\n\t * If `ownsShader` is true, this will also delete the `defaultShader` object.\n\t * \n\t * @method destroy\n\t */\n\tdestroy: function() {\n\t\tthis.vertices = null;\n\t\tthis.indices = null;\n\t\tthis.maxVertices = 0;\n\n\t\tif (this.ownsShader && this.defaultShader)\n\t\t\tthis.defaultShader.destroy();\n\t\tthis.defaultShader = null;\n\t\tthis._shader = null; // remove reference to whatever shader is currently being used\n\n\t\tif (this.mesh) \n\t\t\tthis.mesh.destroy();\n\t\tthis.mesh = null;\n\t}\n});\n\nmodule.exports = BaseBatch;\n"]},"metadata":{},"sourceType":"script"}