{"ast":null,"code":"import loadTexture from './loadTexture';\nimport TextureRegion from './TextureRegion';\n\nfunction concatAndResolveUrl(url, concat) {\n  let url1 = url.split('/');\n  let url2 = concat.split('/');\n  let url3 = [];\n\n  for (let i = 0, l = url1.length; i < l; i++) {\n    if (url1[i] === '..') {\n      url3.pop();\n    } else if (url1[i] === '.') {\n      continue;\n    } else {\n      url3.push(url1[i]);\n    }\n  }\n\n  for (let i = 0, l = url2.length; i < l; i++) {\n    if (url2[i] === '..') {\n      url3.pop();\n    } else if (url2[i] === '.') {\n      continue;\n    } else {\n      url3.push(url2[i]);\n    }\n  }\n\n  return url3.join('/');\n}\n\nconst TextureWrap = {\n  ClampToEdge: 0,\n  Repeat: 1\n};\nexport default (async (gl, packFileUrl, textureOptions) => {\n  const packFileContent = await fetch(packFileUrl).then(res => res.text());\n  const pages = [];\n  const regionsData = [];\n  let pageImage;\n  const lines = packFileContent.split('\\n');\n  let i = 0;\n  let tuple;\n\n  while (true) {\n    let line = lines[i];\n\n    if (line === undefined) {\n      break;\n    }\n\n    if (line.trim().length === 0) {\n      pageImage = null;\n    } else if (pageImage === null) {\n      const file = concatAndResolveUrl(packFileUrl, `../${line}`);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const width = parseInt(tuple[0], 10);\n      const height = parseInt(tuple[1], 10);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const format = tuple[0];\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const [min, max] = tuple;\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const direction = tuple[0];\n      let repeatX = TextureWrap.ClampToEdge;\n      let repeatY = TextureWrap.ClampToEdge;\n\n      if (direction === 'x') {\n        repeatX = TextureWrap.Repeat;\n      } else if (direction === 'y') {\n        repeatY = TextureWrap.Repeat;\n      } else if (direction === 'xy') {\n        repeatX = TextureWrap.Repeat;\n        repeatY = TextureWrap.Repeat;\n      }\n\n      const mipMaps = min !== 'Nearest' && min !== 'Linear';\n      pageImage = {\n        file,\n        width,\n        height,\n        format,\n        mipMaps,\n        min,\n        max,\n        direction,\n        repeatX,\n        repeatY\n      };\n      pages.push(pageImage);\n    } else {\n      const name = line;\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const rotate = tuple[0] === 'true';\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const left = parseInt(tuple[0], 10);\n      const top = parseInt(tuple[1], 10);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const width = parseInt(tuple[0], 10);\n      const height = parseInt(tuple[1], 10);\n      const region = {\n        name,\n        rotate,\n        left,\n        top,\n        width,\n        height,\n        page: pageImage\n      };\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n\n      if (tuple.length === 4) {\n        region.splits = tuple.map(i => parseInt(i, 10));\n        i++;\n        line = lines[i];\n        tuple = line.split(':')[1].split(',').map(s => s.trim());\n\n        if (tuple.length === 4) {\n          region.pads = tuple.map(i => parseInt(i, 10));\n          i++;\n          line = lines[i];\n          tuple = line.split(':')[1].split(',').map(s => s.trim());\n        }\n      }\n\n      region.originalWidth = parseInt(tuple[0], 10);\n      region.originalHeight = parseInt(tuple[1], 10);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      region.offsetX = parseInt(tuple[0], 10);\n      region.offsetY = parseInt(tuple[1], 10);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      region.index = parseInt(tuple[0], 10);\n      regionsData.push(region);\n    }\n\n    i++;\n  }\n\n  for (let page of pages) {\n    page.texture = await loadTexture(gl, page.file, textureOptions);\n    page.invTexWidth = 1 / page.texture.width;\n    page.invTexHeight = 1 / page.texture.height;\n  }\n\n  const regions = [];\n\n  for (let regionData of regionsData) {\n    const {\n      left: x,\n      top: y\n    } = regionData;\n    const width = regionData.rotate ? regionData.height : regionData.width;\n    const height = regionData.rotate ? regionData.width : regionData.height;\n    const {\n      texture,\n      invTexWidth,\n      invTexHeight\n    } = regionData.page;\n    regions.push(new TextureRegion(texture, x, y, width, height, regionData, invTexWidth, invTexHeight, regionData.rotate));\n  }\n\n  return {\n    getPages() {\n      return pages;\n    },\n\n    getRegions() {\n      return regions;\n    },\n\n    findRegion(name, index) {\n      for (let i = 0; i < regions.length; i++) {\n        let region = regions[i];\n        if (region.name !== name) continue;\n        if (index !== undefined && region.index !== index) continue;\n        return region;\n      }\n\n      return null;\n    },\n\n    findRegions(name) {\n      return regions.filter(region => region.name === name).sort((a, b) => a.index - b.index);\n    }\n\n  };\n});","map":{"version":3,"sources":["E:/fcatcher-client/node_modules/gdxjs/lib/loadAtlas.js"],"names":["loadTexture","TextureRegion","concatAndResolveUrl","url","concat","url1","split","url2","url3","i","l","length","pop","push","join","TextureWrap","ClampToEdge","Repeat","gl","packFileUrl","textureOptions","packFileContent","fetch","then","res","text","pages","regionsData","pageImage","lines","tuple","line","undefined","trim","file","map","s","width","parseInt","height","format","min","max","direction","repeatX","repeatY","mipMaps","name","rotate","left","top","region","page","splits","pads","originalWidth","originalHeight","offsetX","offsetY","index","texture","invTexWidth","invTexHeight","regions","regionData","x","y","getPages","getRegions","findRegion","findRegions","filter","sort","a","b"],"mappings":"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","sourcesContent":["import loadTexture from './loadTexture';\nimport TextureRegion from './TextureRegion';\n\nfunction concatAndResolveUrl(url, concat) {\n  let url1 = url.split('/');\n  let url2 = concat.split('/');\n  let url3 = [];\n\n  for (let i = 0, l = url1.length; i < l; i++) {\n    if (url1[i] === '..') {\n      url3.pop();\n    } else if (url1[i] === '.') {\n      continue;\n    } else {\n      url3.push(url1[i]);\n    }\n  }\n\n  for (let i = 0, l = url2.length; i < l; i++) {\n    if (url2[i] === '..') {\n      url3.pop();\n    } else if (url2[i] === '.') {\n      continue;\n    } else {\n      url3.push(url2[i]);\n    }\n  }\n\n  return url3.join('/');\n}\n\nconst TextureWrap = {\n  ClampToEdge: 0,\n  Repeat: 1\n};\nexport default (async (gl, packFileUrl, textureOptions) => {\n  const packFileContent = await fetch(packFileUrl).then(res => res.text());\n  const pages = [];\n  const regionsData = [];\n  let pageImage;\n  const lines = packFileContent.split('\\n');\n  let i = 0;\n  let tuple;\n\n  while (true) {\n    let line = lines[i];\n\n    if (line === undefined) {\n      break;\n    }\n\n    if (line.trim().length === 0) {\n      pageImage = null;\n    } else if (pageImage === null) {\n      const file = concatAndResolveUrl(packFileUrl, `../${line}`);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const width = parseInt(tuple[0], 10);\n      const height = parseInt(tuple[1], 10);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const format = tuple[0];\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const [min, max] = tuple;\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const direction = tuple[0];\n      let repeatX = TextureWrap.ClampToEdge;\n      let repeatY = TextureWrap.ClampToEdge;\n\n      if (direction === 'x') {\n        repeatX = TextureWrap.Repeat;\n      } else if (direction === 'y') {\n        repeatY = TextureWrap.Repeat;\n      } else if (direction === 'xy') {\n        repeatX = TextureWrap.Repeat;\n        repeatY = TextureWrap.Repeat;\n      }\n\n      const mipMaps = min !== 'Nearest' && min !== 'Linear';\n      pageImage = {\n        file,\n        width,\n        height,\n        format,\n        mipMaps,\n        min,\n        max,\n        direction,\n        repeatX,\n        repeatY\n      };\n      pages.push(pageImage);\n    } else {\n      const name = line;\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const rotate = tuple[0] === 'true';\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const left = parseInt(tuple[0], 10);\n      const top = parseInt(tuple[1], 10);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const width = parseInt(tuple[0], 10);\n      const height = parseInt(tuple[1], 10);\n      const region = {\n        name,\n        rotate,\n        left,\n        top,\n        width,\n        height,\n        page: pageImage\n      };\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n\n      if (tuple.length === 4) {\n        region.splits = tuple.map(i => parseInt(i, 10));\n        i++;\n        line = lines[i];\n        tuple = line.split(':')[1].split(',').map(s => s.trim());\n\n        if (tuple.length === 4) {\n          region.pads = tuple.map(i => parseInt(i, 10));\n          i++;\n          line = lines[i];\n          tuple = line.split(':')[1].split(',').map(s => s.trim());\n        }\n      }\n\n      region.originalWidth = parseInt(tuple[0], 10);\n      region.originalHeight = parseInt(tuple[1], 10);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      region.offsetX = parseInt(tuple[0], 10);\n      region.offsetY = parseInt(tuple[1], 10);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      region.index = parseInt(tuple[0], 10);\n      regionsData.push(region);\n    }\n\n    i++;\n  }\n\n  for (let page of pages) {\n    page.texture = await loadTexture(gl, page.file, textureOptions);\n    page.invTexWidth = 1 / page.texture.width;\n    page.invTexHeight = 1 / page.texture.height;\n  }\n\n  const regions = [];\n\n  for (let regionData of regionsData) {\n    const {\n      left: x,\n      top: y\n    } = regionData;\n    const width = regionData.rotate ? regionData.height : regionData.width;\n    const height = regionData.rotate ? regionData.width : regionData.height;\n    const {\n      texture,\n      invTexWidth,\n      invTexHeight\n    } = regionData.page;\n    regions.push(new TextureRegion(texture, x, y, width, height, regionData, invTexWidth, invTexHeight, regionData.rotate));\n  }\n\n  return {\n    getPages() {\n      return pages;\n    },\n\n    getRegions() {\n      return regions;\n    },\n\n    findRegion(name, index) {\n      for (let i = 0; i < regions.length; i++) {\n        let region = regions[i];\n        if (region.name !== name) continue;\n        if (index !== undefined && region.index !== index) continue;\n        return region;\n      }\n\n      return null;\n    },\n\n    findRegions(name) {\n      return regions.filter(region => region.name === name).sort((a, b) => a.index - b.index);\n    }\n\n  };\n});"]},"metadata":{},"sourceType":"module"}