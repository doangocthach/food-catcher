{"ast":null,"code":"function hasGetterOrSetter(def) {\n  return !!def.get && typeof def.get === \"function\" || !!def.set && typeof def.set === \"function\";\n}\n\nfunction getProperty(definition, k, isClassDescriptor) {\n  //This may be a lightweight object, OR it might be a property\n  //that was defined previously.\n  //For simple class descriptors we can just assume its NOT previously defined.\n  var def = isClassDescriptor ? definition[k] : Object.getOwnPropertyDescriptor(definition, k);\n\n  if (!isClassDescriptor && def.value && typeof def.value === \"object\") {\n    def = def.value;\n  } //This might be a regular property, or it may be a getter/setter the user defined in a class.\n\n\n  if (def && hasGetterOrSetter(def)) {\n    if (typeof def.enumerable === \"undefined\") def.enumerable = true;\n    if (typeof def.configurable === \"undefined\") def.configurable = true;\n    return def;\n  } else {\n    return false;\n  }\n}\n\nfunction hasNonConfigurable(obj, k) {\n  var prop = Object.getOwnPropertyDescriptor(obj, k);\n  if (!prop) return false;\n  if (prop.value && typeof prop.value === \"object\") prop = prop.value;\n  if (prop.configurable === false) return true;\n  return false;\n} //TODO: On create, \n//\t\tOn mixin, \n\n\nfunction extend(ctor, definition, isClassDescriptor, extend) {\n  for (var k in definition) {\n    if (!definition.hasOwnProperty(k)) continue;\n    var def = getProperty(definition, k, isClassDescriptor);\n\n    if (def !== false) {\n      //If Extends is used, we will check its prototype to see if \n      //the final variable exists.\n      var parent = extend || ctor;\n\n      if (hasNonConfigurable(parent.prototype, k)) {\n        //just skip the final property\n        if (Class.ignoreFinals) continue; //We cannot re-define a property that is configurable=false.\n        //So we will consider them final and throw an error. This is by\n        //default so it is clear to the developer what is happening.\n        //You can set ignoreFinals to true if you need to extend a class\n        //which has configurable=false; it will simply not re-define final properties.\n\n        throw new Error(\"cannot override final property '\" + k + \"', set Class.ignoreFinals = true to skip\");\n      }\n\n      Object.defineProperty(ctor.prototype, k, def);\n    } else {\n      ctor.prototype[k] = definition[k];\n    }\n  }\n}\n/**\n */\n\n\nfunction mixin(myClass, mixins) {\n  if (!mixins) return;\n  if (!Array.isArray(mixins)) mixins = [mixins];\n\n  for (var i = 0; i < mixins.length; i++) {\n    extend(myClass, mixins[i].prototype || mixins[i]);\n  }\n}\n/**\n * Creates a new class with the given descriptor.\n * The constructor, defined by the name `initialize`,\n * is an optional function. If unspecified, an anonymous\n * function will be used which calls the parent class (if\n * one exists). \n *\n * You can also use `Extends` and `Mixins` to provide subclassing\n * and inheritance.\n *\n * @class  Class\n * @constructor\n * @param {Object} definition a dictionary of functions for the class\n * @example\n *\n * \t\tvar MyClass = new Class({\n * \t\t\n * \t\t\tinitialize: function() {\n * \t\t\t\tthis.foo = 2.0;\n * \t\t\t},\n *\n * \t\t\tbar: function() {\n * \t\t\t\treturn this.foo + 5;\n * \t\t\t}\n * \t\t});\n */\n\n\nfunction Class(definition) {\n  if (!definition) definition = {}; //The variable name here dictates what we see in Chrome debugger\n\n  var initialize;\n  var Extends;\n\n  if (definition.initialize) {\n    if (typeof definition.initialize !== \"function\") throw new Error(\"initialize must be a function\");\n    initialize = definition.initialize; //Usually we should avoid \"delete\" in V8 at all costs.\n    //However, its unlikely to make any performance difference\n    //here since we only call this on class creation (i.e. not object creation).\n\n    delete definition.initialize;\n  } else {\n    if (definition.Extends) {\n      var base = definition.Extends;\n\n      initialize = function initialize() {\n        base.apply(this, arguments);\n      };\n    } else {\n      initialize = function initialize() {};\n    }\n  }\n\n  if (definition.Extends) {\n    initialize.prototype = Object.create(definition.Extends.prototype);\n    initialize.prototype.constructor = initialize; //for getOwnPropertyDescriptor to work, we need to act\n    //directly on the Extends (or Mixin)\n\n    Extends = definition.Extends;\n    delete definition.Extends;\n  } else {\n    initialize.prototype.constructor = initialize;\n  } //Grab the mixins, if they are specified...\n\n\n  var mixins = null;\n\n  if (definition.Mixins) {\n    mixins = definition.Mixins;\n    delete definition.Mixins;\n  } //First, mixin if we can.\n\n\n  mixin(initialize, mixins); //Now we grab the actual definition which defines the overrides.\n\n  extend(initialize, definition, true, Extends);\n  return initialize;\n}\n\n;\nClass.extend = extend;\nClass.mixin = mixin;\nClass.ignoreFinals = false;\nmodule.exports = Class;","map":{"version":3,"sources":["E:/fcatcher-client/node_modules/klasse/index.js"],"names":["hasGetterOrSetter","def","get","set","getProperty","definition","k","isClassDescriptor","Object","getOwnPropertyDescriptor","value","enumerable","configurable","hasNonConfigurable","obj","prop","extend","ctor","hasOwnProperty","parent","prototype","Class","ignoreFinals","Error","defineProperty","mixin","myClass","mixins","Array","isArray","i","length","initialize","Extends","base","apply","arguments","create","constructor","Mixins","module","exports"],"mappings":"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","sourcesContent":["function hasGetterOrSetter(def) {\n\treturn (!!def.get && typeof def.get === \"function\") || (!!def.set && typeof def.set === \"function\");\n}\n\nfunction getProperty(definition, k, isClassDescriptor) {\n\t//This may be a lightweight object, OR it might be a property\n\t//that was defined previously.\n\t\n\t//For simple class descriptors we can just assume its NOT previously defined.\n\tvar def = isClassDescriptor \n\t\t\t\t? definition[k] \n\t\t\t\t: Object.getOwnPropertyDescriptor(definition, k);\n\n\tif (!isClassDescriptor && def.value && typeof def.value === \"object\") {\n\t\tdef = def.value;\n\t}\n\n\n\t//This might be a regular property, or it may be a getter/setter the user defined in a class.\n\tif ( def && hasGetterOrSetter(def) ) {\n\t\tif (typeof def.enumerable === \"undefined\")\n\t\t\tdef.enumerable = true;\n\t\tif (typeof def.configurable === \"undefined\")\n\t\t\tdef.configurable = true;\n\t\treturn def;\n\t} else {\n\t\treturn false;\n\t}\n}\n\nfunction hasNonConfigurable(obj, k) {\n\tvar prop = Object.getOwnPropertyDescriptor(obj, k);\n\tif (!prop)\n\t\treturn false;\n\n\tif (prop.value && typeof prop.value === \"object\")\n\t\tprop = prop.value;\n\n\tif (prop.configurable === false) \n\t\treturn true;\n\n\treturn false;\n}\n\n//TODO: On create, \n//\t\tOn mixin, \n\nfunction extend(ctor, definition, isClassDescriptor, extend) {\n\tfor (var k in definition) {\n\t\tif (!definition.hasOwnProperty(k))\n\t\t\tcontinue;\n\n\t\tvar def = getProperty(definition, k, isClassDescriptor);\n\n\t\tif (def !== false) {\n\t\t\t//If Extends is used, we will check its prototype to see if \n\t\t\t//the final variable exists.\n\t\t\t\n\t\t\tvar parent = extend || ctor;\n\t\t\tif (hasNonConfigurable(parent.prototype, k)) {\n\n\t\t\t\t//just skip the final property\n\t\t\t\tif (Class.ignoreFinals)\n\t\t\t\t\tcontinue;\n\n\t\t\t\t//We cannot re-define a property that is configurable=false.\n\t\t\t\t//So we will consider them final and throw an error. This is by\n\t\t\t\t//default so it is clear to the developer what is happening.\n\t\t\t\t//You can set ignoreFinals to true if you need to extend a class\n\t\t\t\t//which has configurable=false; it will simply not re-define final properties.\n\t\t\t\tthrow new Error(\"cannot override final property '\"+k\n\t\t\t\t\t\t\t+\"', set Class.ignoreFinals = true to skip\");\n\t\t\t}\n\n\t\t\tObject.defineProperty(ctor.prototype, k, def);\n\t\t} else {\n\t\t\tctor.prototype[k] = definition[k];\n\t\t}\n\n\t}\n}\n\n/**\n */\nfunction mixin(myClass, mixins) {\n\tif (!mixins)\n\t\treturn;\n\n\tif (!Array.isArray(mixins))\n\t\tmixins = [mixins];\n\n\tfor (var i=0; i<mixins.length; i++) {\n\t\textend(myClass, mixins[i].prototype || mixins[i]);\n\t}\n}\n\n/**\n * Creates a new class with the given descriptor.\n * The constructor, defined by the name `initialize`,\n * is an optional function. If unspecified, an anonymous\n * function will be used which calls the parent class (if\n * one exists). \n *\n * You can also use `Extends` and `Mixins` to provide subclassing\n * and inheritance.\n *\n * @class  Class\n * @constructor\n * @param {Object} definition a dictionary of functions for the class\n * @example\n *\n * \t\tvar MyClass = new Class({\n * \t\t\n * \t\t\tinitialize: function() {\n * \t\t\t\tthis.foo = 2.0;\n * \t\t\t},\n *\n * \t\t\tbar: function() {\n * \t\t\t\treturn this.foo + 5;\n * \t\t\t}\n * \t\t});\n */\nfunction Class(definition) {\n\tif (!definition)\n\t\tdefinition = {};\n\n\t//The variable name here dictates what we see in Chrome debugger\n\tvar initialize;\n\tvar Extends;\n\n\tif (definition.initialize) {\n\t\tif (typeof definition.initialize !== \"function\")\n\t\t\tthrow new Error(\"initialize must be a function\");\n\t\tinitialize = definition.initialize;\n\n\t\t//Usually we should avoid \"delete\" in V8 at all costs.\n\t\t//However, its unlikely to make any performance difference\n\t\t//here since we only call this on class creation (i.e. not object creation).\n\t\tdelete definition.initialize;\n\t} else {\n\t\tif (definition.Extends) {\n\t\t\tvar base = definition.Extends;\n\t\t\tinitialize = function () {\n\t\t\t\tbase.apply(this, arguments);\n\t\t\t}; \n\t\t} else {\n\t\t\tinitialize = function () {}; \n\t\t}\n\t}\n\n\tif (definition.Extends) {\n\t\tinitialize.prototype = Object.create(definition.Extends.prototype);\n\t\tinitialize.prototype.constructor = initialize;\n\t\t//for getOwnPropertyDescriptor to work, we need to act\n\t\t//directly on the Extends (or Mixin)\n\t\tExtends = definition.Extends;\n\t\tdelete definition.Extends;\n\t} else {\n\t\tinitialize.prototype.constructor = initialize;\n\t}\n\n\t//Grab the mixins, if they are specified...\n\tvar mixins = null;\n\tif (definition.Mixins) {\n\t\tmixins = definition.Mixins;\n\t\tdelete definition.Mixins;\n\t}\n\n\t//First, mixin if we can.\n\tmixin(initialize, mixins);\n\n\t//Now we grab the actual definition which defines the overrides.\n\textend(initialize, definition, true, Extends);\n\n\treturn initialize;\n};\n\nClass.extend = extend;\nClass.mixin = mixin;\nClass.ignoreFinals = false;\n\nmodule.exports = Class;"]},"metadata":{},"sourceType":"script"}