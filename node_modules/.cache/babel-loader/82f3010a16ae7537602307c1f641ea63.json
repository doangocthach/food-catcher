{"ast":null,"code":"/**\n * A fast and efficient 2D sprite batcher.\n * \n * @module kami-batch\n */\n// Requires....\nvar Class = require('klasse');\n\nvar Mesh = require('kami-mesh-buffer');\n\nvar ShaderProgram = require('kami-shader');\n\nvar BaseBatch = require('kami-base-batch');\n\nvar mat4 = require('gl-matrix').mat4;\n/**\n * A basic implementation of a batcher which draws 2D sprites.\n * This uses two triangles (quads) with indexed and interleaved\n * vertex data. Each vertex holds 5 floats (Position.xy, Color, TexCoord0.xy).\n *\n * The color is packed into a single float to reduce vertex bandwidth, and\n * the data is interleaved for best performance. We use a static index buffer,\n * and a dynamic vertex buffer that is updated with bufferSubData. \n * \n * @example\n *      //create a new batcher\n *      var batch = require('kami-batch')(context);\n *\n *      function render() {\n *          batch.begin();\n *          \n *          //draw some sprites in between begin and end...\n *          batch.draw( texture, 0, 0, 25, 32 );\n *          batch.draw( texture1, 0, 25, 42, 23 );\n * \n *          batch.end();\n *      }\n * \n * @class  SpriteBatch\n * @uses BaseBatch\n * @constructor\n * @param {WebGLContext} context the context for this batch\n * @param {Object} options the options\n * @param {Number} options.size the optional size of this batch, i.e. max number of quads\n */\n\n\nvar SpriteBatch = new Class({\n  //inherit some stuff onto this prototype\n  Mixins: BaseBatch,\n  //Constructor\n  initialize: function SpriteBatch(context, options) {\n    if (!(this instanceof SpriteBatch)) return new SpriteBatch(context, options);\n    BaseBatch.call(this, context, options);\n    /**\n     * The projection Float32Array vec2 which is\n     * used to avoid some matrix calculations.\n     *\n     * @property projection\n     * @type {Float32Array}\n     */\n    // this.projection = new Float32Array(2);\n    // var ctxCanvas = this.context.gl.canvas;\n    //Sets up a default projection vector so that the batch works without setProjection\n    // this.projection[0] = ctxCanvas.width/2;\n    // this.projection[1] = ctxCanvas.height/2;\n\n    this.projection = mat4.create();\n    /**\n     * The currently bound texture. Do not modify.\n     * \n     * @property {Texture} texture\n     * @readOnly\n     */\n\n    this.texture = null;\n  },\n\n  /**\n   * This is a convenience function to set the batch's projection\n   * matrix to an orthographic 2D projection, based on the given screen\n   * size. This allows users to render in 2D without any need for a camera.\n   * \n   * @param  {[type]} width  [description]\n   * @param  {[type]} height [description]\n   * @return {[type]}        [description]\n   */\n  resize: function (width, height) {\n    this.setProjection(width / 2, height / 2);\n  },\n\n  /**\n   * The number of floats per vertex for this batcher \n   * (Position.xy + Color + TexCoord0.xy).\n   *\n   * @method  getVertexSize\n   * @return {Number} the number of floats per vertex\n   */\n  getVertexSize: function () {\n    return SpriteBatch.VERTEX_SIZE;\n  },\n\n  /**\n   * Used internally to return the Position, Color, and TexCoord0 attributes.\n   *\n   * @method  _createVertexAttribuets\n   * @protected\n   * @return {[type]} [description]\n   */\n  _createVertexAttributes: function () {\n    var gl = this.context.gl;\n    return [new Mesh.Attrib(ShaderProgram.POSITION_ATTRIBUTE, 2), //pack the color for smaller CPU -> GPU bandwidth\n    new Mesh.Attrib(ShaderProgram.COLOR_ATTRIBUTE, 4, null, gl.UNSIGNED_BYTE, true, 1), new Mesh.Attrib(ShaderProgram.TEXCOORD_ATTRIBUTE + '0', 2)];\n  },\n\n  /**\n   * Sets the projection vector, an x and y\n   * defining the middle points of your stage.\n   *\n   * @method setProjection\n   * @param {Number} x the x projection value\n   * @param {Number} y the y projection value\n   */\n  setProjection: function (mat4) {\n    this.projection = mat4;\n\n    if (this.drawing && (x != oldX || y != oldY)) {\n      this.flush();\n      this.updateMatrices();\n    }\n  },\n\n  /**\n   * Creates a default shader for this batch.\n   *\n   * @method  _createShader\n   * @protected\n   * @return {ShaderProgram} a new instance of ShaderProgram\n   */\n  _createShader: function () {\n    var shader = new ShaderProgram(this.context, SpriteBatch.DEFAULT_VERT_SHADER, SpriteBatch.DEFAULT_FRAG_SHADER);\n    if (shader.log) console.warn('Shader Log:\\n' + shader.log);\n    return shader;\n  },\n\n  /**\n   * This is called during rendering to update projection/transform\n   * matrices and upload the new values to the shader. For example,\n   * if the user calls setProjection mid-draw, the batch will flush\n   * and this will be called before continuing to add items to the batch.\n   *\n   * You generally should not need to call this directly.\n   * \n   * @method  updateMatrices\n   * @protected\n   */\n  updateMatrices: function () {\n    this.shader.setUniformMatrix4('u_projection', this.projection);\n  },\n\n  /**\n   * Called before rendering, and binds the current texture.\n   * \n   * @method _preRender\n   * @protected\n   */\n  _preRender: function () {\n    if (this.texture) this.texture.bind();\n  },\n\n  /**\n   * Binds the shader, disables depth writing, \n   * enables blending, activates texture unit 0, and sends\n   * default matrices and sampler2D uniforms to the shader.\n   *\n   * @method  begin\n   */\n  begin: function () {\n    //sprite batch doesn't hold a reference to GL since it is volatile\n    var gl = this.context.gl; //This binds the shader and mesh!\n\n    BaseBatch.prototype.begin.call(this);\n    this.updateMatrices(); //send projection/transform to shader\n    //upload the sampler uniform. not necessary every flush so we just\n    //do it here.\n\n    this.shader.setUniformi('u_texture0', 0); //disable depth mask\n\n    gl.depthMask(false);\n  },\n\n  /**\n   * Ends the sprite batcher and flushes any remaining data to the GPU.\n   * \n   * @method end\n   */\n  end: function () {\n    //sprite batch doesn't hold a reference to GL since it is volatile\n    var gl = this.context.gl; //just do direct parent call for speed here\n    //This binds the shader and mesh!\n\n    BaseBatch.prototype.end.call(this);\n    gl.depthMask(true);\n  },\n\n  /**\n   * Flushes the batch to the GPU. This should be called when\n   * state changes, such as blend functions, depth or stencil states,\n   * shaders, and so forth.\n   * \n   * @method flush\n   */\n  flush: function () {\n    //ignore flush if texture is null or our batch is empty\n    if (!this.texture) return;\n    if (this.idx === 0) return;\n    BaseBatch.prototype.flush.call(this);\n    SpriteBatch.totalRenderCalls++;\n  },\n  drawRegion: function (region, x, y, width, height) {\n    this.draw(region.texture, x, y, width, height, region.u, region.v, region.u2, region.v2);\n  },\n\n  /**\n   * Adds a sprite to this batch. The sprite is drawn in \n   * screen-space with the origin at the upper-left corner (y-down).\n   * \n   * @method draw\n   * @param  {Texture} texture the Texture\n   * @param  {Number} x       the x position in pixels, defaults to zero\n   * @param  {Number} y       the y position in pixels, defaults to zero\n   * @param  {Number} width   the width in pixels, defaults to the texture width\n   * @param  {Number} height  the height in pixels, defaults to the texture height\n   * @param  {Number} u1      the first U coordinate, default zero\n   * @param  {Number} v1      the first V coordinate, default zero\n   * @param  {Number} u2      the second U coordinate, default one\n   * @param  {Number} v2      the second V coordinate, default one\n   */\n  draw: function (texture, x, y, width, height, originX = 0, originY = 0, rotation = 0, scaleX = 1, scaleY = 1, u1 = 0, v1 = 0, u2 = 1, v2 = 1) {\n    if (!this.drawing) throw 'Illegal State: trying to draw a batch before begin()'; //don't draw anything if GL tex doesn't exist..\n\n    if (!texture) return;\n\n    if (this.texture === null || this.texture.id !== texture.id) {\n      //new texture.. flush previous data\n      this.flush();\n      this.texture = texture;\n    } else if (this.idx == this.vertices.length) {\n      this.flush(); //we've reached our max, flush before pushing more data\n    }\n\n    width = width === 0 ? width : width || texture.width;\n    height = height === 0 ? height : height || texture.height;\n    x = x || 0;\n    y = y || 0;\n    var x1 = -originX;\n    var x2 = width - originX;\n    var x3 = width - originX;\n    var x4 = -originX;\n    var y1 = -originY;\n    var y2 = -originY;\n    var y3 = height - originY;\n    var y4 = height - originY;\n    var c = this.color;\n\n    if (scaleX !== 1) {\n      x1 = x1 * scaleX;\n      x2 = x2 * scaleX;\n      x3 = x3 * scaleX;\n      x4 = x4 * scaleX;\n    }\n\n    if (scaleY !== 1) {\n      y1 = y1 * scaleY;\n      y2 = y2 * scaleY;\n      y3 = y3 * scaleY;\n      y4 = y4 * scaleY;\n    }\n\n    if (rotation !== 0) {\n      var cos = Math.cos(rotation);\n      var sin = Math.sin(rotation);\n      var rotatedX1 = cos * x1 - sin * y1;\n      var rotatedY1 = sin * x1 + cos * y1;\n      var rotatedX2 = cos * x2 - sin * y2;\n      var rotatedY2 = sin * x2 + cos * y2;\n      var rotatedX3 = cos * x3 - sin * y3;\n      var rotatedY3 = sin * x3 + cos * y3;\n      var rotatedX4 = cos * x4 - sin * y4;\n      var rotatedY4 = sin * x4 + cos * y4;\n      x1 = rotatedX1;\n      x2 = rotatedX2;\n      x3 = rotatedX3;\n      x4 = rotatedX4;\n      y1 = rotatedY1;\n      y2 = rotatedY2;\n      y3 = rotatedY3;\n      y4 = rotatedY4;\n    }\n\n    x1 += x + originX;\n    x2 += x + originX;\n    x3 += x + originX;\n    x4 += x + originX;\n    y1 += y + originY;\n    y2 += y + originY;\n    y3 += y + originY;\n    y4 += y + originY; //xy\n\n    this.vertices[this.idx++] = x1;\n    this.vertices[this.idx++] = y1; //color\n\n    this.vertices[this.idx++] = c; //uv\n\n    this.vertices[this.idx++] = u1;\n    this.vertices[this.idx++] = v1; //xy\n\n    this.vertices[this.idx++] = x2;\n    this.vertices[this.idx++] = y2; //color\n\n    this.vertices[this.idx++] = c; //uv\n\n    this.vertices[this.idx++] = u2;\n    this.vertices[this.idx++] = v1; //xy\n\n    this.vertices[this.idx++] = x3;\n    this.vertices[this.idx++] = y3; //color\n\n    this.vertices[this.idx++] = c; //uv\n\n    this.vertices[this.idx++] = u2;\n    this.vertices[this.idx++] = v2; //xy\n\n    this.vertices[this.idx++] = x4;\n    this.vertices[this.idx++] = y4; //color\n\n    this.vertices[this.idx++] = c; //uv\n\n    this.vertices[this.idx++] = u1;\n    this.vertices[this.idx++] = v2;\n  },\n\n  /**\n   * Adds a single quad mesh to this sprite batch from the given\n   * array of vertices. The sprite is drawn in \n   * screen-space with the origin at the upper-left corner (y-down).\n   *\n   * This reads 20 interleaved floats from the given offset index, in the format\n   *\n   *  { x, y, color, u, v,\n   *      ...  }\n   *\n   * @method  drawVertices\n   * @param {Texture} texture the Texture object\n   * @param {Float32Array} verts an array of vertices\n   * @param {Number} off the offset into the vertices array to read from\n   */\n  drawVertices: function (texture, verts, off) {\n    if (!this.drawing) throw 'Illegal State: trying to draw a batch before begin()'; //don't draw anything if GL tex doesn't exist..\n\n    if (!texture) return;\n\n    if (this.texture != texture) {\n      //new texture.. flush previous data\n      this.flush();\n      this.texture = texture;\n    } else if (this.idx == this.vertices.length) {\n      this.flush(); //we've reached our max, flush before pushing more data\n    }\n\n    off = off || 0; //TODO: use a loop here?\n    //xy\n\n    this.vertices[this.idx++] = verts[off++];\n    this.vertices[this.idx++] = verts[off++]; //color\n\n    this.vertices[this.idx++] = verts[off++]; //uv\n\n    this.vertices[this.idx++] = verts[off++];\n    this.vertices[this.idx++] = verts[off++]; //xy\n\n    this.vertices[this.idx++] = verts[off++];\n    this.vertices[this.idx++] = verts[off++]; //color\n\n    this.vertices[this.idx++] = verts[off++]; //uv\n\n    this.vertices[this.idx++] = verts[off++];\n    this.vertices[this.idx++] = verts[off++]; //xy\n\n    this.vertices[this.idx++] = verts[off++];\n    this.vertices[this.idx++] = verts[off++]; //color\n\n    this.vertices[this.idx++] = verts[off++]; //uv\n\n    this.vertices[this.idx++] = verts[off++];\n    this.vertices[this.idx++] = verts[off++]; //xy\n\n    this.vertices[this.idx++] = verts[off++];\n    this.vertices[this.idx++] = verts[off++]; //color\n\n    this.vertices[this.idx++] = verts[off++]; //uv\n\n    this.vertices[this.idx++] = verts[off++];\n    this.vertices[this.idx++] = verts[off++];\n  }\n});\n/**\n * The default vertex size, i.e. number of floats per vertex.\n * @attribute  VERTEX_SIZE\n * @static\n * @final\n * @type {Number}\n * @default  5\n */\n\nSpriteBatch.VERTEX_SIZE = 5;\n/**\n * Incremented after each draw call, can be used for debugging.\n *\n *     SpriteBatch.totalRenderCalls = 0;\n *\n *     ... draw your scene ...\n *\n *     console.log(\"Draw calls per frame:\", SpriteBatch.totalRenderCalls);\n *\n * \n * @attribute  totalRenderCalls\n * @static\n * @type {Number}\n * @default  0\n */\n\nSpriteBatch.totalRenderCalls = 0;\nSpriteBatch.DEFAULT_FRAG_SHADER = ['precision mediump float;', 'varying vec2 vTexCoord0;', 'varying vec4 vColor;', 'uniform sampler2D u_texture0;', 'void main(void) {', '   gl_FragColor = texture2D(u_texture0, vTexCoord0) * vColor;', '}'].join('\\n');\nSpriteBatch.DEFAULT_VERT_SHADER = ['attribute vec4 ' + ShaderProgram.POSITION_ATTRIBUTE + ';', 'attribute vec4 ' + ShaderProgram.COLOR_ATTRIBUTE + ';', 'attribute vec2 ' + ShaderProgram.TEXCOORD_ATTRIBUTE + '0;', 'uniform mat4 u_projection;', 'varying vec2 vTexCoord0;', 'varying vec4 vColor;', 'void main(void) {', ///TODO: use a projection and transform matrix\n'   gl_Position =  u_projection * ' + ShaderProgram.POSITION_ATTRIBUTE + ';', '   vTexCoord0 = ' + ShaderProgram.TEXCOORD_ATTRIBUTE + '0;', '   vColor = ' + ShaderProgram.COLOR_ATTRIBUTE + ';', '   vColor.a = vColor.a * (256.0/255.0);', //this is so the alpha sits at 0.0 or 1.0\n'}'].join('\\n');\nmodule.exports = SpriteBatch;","map":{"version":3,"sources":["E:/fcatcher-client/node_modules/kami-batch2/index.js"],"names":["Class","require","Mesh","ShaderProgram","BaseBatch","mat4","SpriteBatch","Mixins","initialize","context","options","call","projection","create","texture","resize","width","height","setProjection","getVertexSize","VERTEX_SIZE","_createVertexAttributes","gl","Attrib","POSITION_ATTRIBUTE","COLOR_ATTRIBUTE","UNSIGNED_BYTE","TEXCOORD_ATTRIBUTE","drawing","x","oldX","y","oldY","flush","updateMatrices","_createShader","shader","DEFAULT_VERT_SHADER","DEFAULT_FRAG_SHADER","log","console","warn","setUniformMatrix4","_preRender","bind","begin","prototype","setUniformi","depthMask","end","idx","totalRenderCalls","drawRegion","region","draw","u","v","u2","v2","originX","originY","rotation","scaleX","scaleY","u1","v1","id","vertices","length","x1","x2","x3","x4","y1","y2","y3","y4","c","color","cos","Math","sin","rotatedX1","rotatedY1","rotatedX2","rotatedY2","rotatedX3","rotatedY3","rotatedX4","rotatedY4","drawVertices","verts","off","join","module","exports"],"mappings":"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","sourcesContent":["/**\n * A fast and efficient 2D sprite batcher.\n * \n * @module kami-batch\n */\n\n// Requires....\nvar Class = require('klasse');\n\nvar Mesh = require('kami-mesh-buffer');\nvar ShaderProgram = require('kami-shader');\nvar BaseBatch = require('kami-base-batch');\nvar mat4 = require('gl-matrix').mat4;\n\n/**\n * A basic implementation of a batcher which draws 2D sprites.\n * This uses two triangles (quads) with indexed and interleaved\n * vertex data. Each vertex holds 5 floats (Position.xy, Color, TexCoord0.xy).\n *\n * The color is packed into a single float to reduce vertex bandwidth, and\n * the data is interleaved for best performance. We use a static index buffer,\n * and a dynamic vertex buffer that is updated with bufferSubData. \n * \n * @example\n *      //create a new batcher\n *      var batch = require('kami-batch')(context);\n *\n *      function render() {\n *          batch.begin();\n *          \n *          //draw some sprites in between begin and end...\n *          batch.draw( texture, 0, 0, 25, 32 );\n *          batch.draw( texture1, 0, 25, 42, 23 );\n * \n *          batch.end();\n *      }\n * \n * @class  SpriteBatch\n * @uses BaseBatch\n * @constructor\n * @param {WebGLContext} context the context for this batch\n * @param {Object} options the options\n * @param {Number} options.size the optional size of this batch, i.e. max number of quads\n */\nvar SpriteBatch = new Class({\n\t//inherit some stuff onto this prototype\n\tMixins: BaseBatch,\n\n\t//Constructor\n\tinitialize: function SpriteBatch(context, options) {\n\t\tif (!(this instanceof SpriteBatch))\n\t\t\treturn new SpriteBatch(context, options);\n\t\tBaseBatch.call(this, context, options);\n\n\t\t/**\n\t\t * The projection Float32Array vec2 which is\n\t\t * used to avoid some matrix calculations.\n\t\t *\n\t\t * @property projection\n\t\t * @type {Float32Array}\n\t\t */\n\t\t// this.projection = new Float32Array(2);\n\n\t\t// var ctxCanvas = this.context.gl.canvas;\n\t\t//Sets up a default projection vector so that the batch works without setProjection\n\t\t// this.projection[0] = ctxCanvas.width/2;\n\t\t// this.projection[1] = ctxCanvas.height/2;\n\t\tthis.projection = mat4.create();\n\n\t\t/**\n\t\t * The currently bound texture. Do not modify.\n\t\t * \n\t\t * @property {Texture} texture\n\t\t * @readOnly\n\t\t */\n\t\tthis.texture = null;\n\t},\n\n\t/**\n\t * This is a convenience function to set the batch's projection\n\t * matrix to an orthographic 2D projection, based on the given screen\n\t * size. This allows users to render in 2D without any need for a camera.\n\t * \n\t * @param  {[type]} width  [description]\n\t * @param  {[type]} height [description]\n\t * @return {[type]}        [description]\n\t */\n\tresize: function(width, height) {\n\t\tthis.setProjection(width / 2, height / 2);\n\t},\n\n\t/**\n\t * The number of floats per vertex for this batcher \n\t * (Position.xy + Color + TexCoord0.xy).\n\t *\n\t * @method  getVertexSize\n\t * @return {Number} the number of floats per vertex\n\t */\n\tgetVertexSize: function() {\n\t\treturn SpriteBatch.VERTEX_SIZE;\n\t},\n\n\t/**\n\t * Used internally to return the Position, Color, and TexCoord0 attributes.\n\t *\n\t * @method  _createVertexAttribuets\n\t * @protected\n\t * @return {[type]} [description]\n\t */\n\t_createVertexAttributes: function() {\n\t\tvar gl = this.context.gl;\n\n\t\treturn [\n\t\t\tnew Mesh.Attrib(ShaderProgram.POSITION_ATTRIBUTE, 2),\n\t\t\t//pack the color for smaller CPU -> GPU bandwidth\n\t\t\tnew Mesh.Attrib(\n\t\t\t\tShaderProgram.COLOR_ATTRIBUTE,\n\t\t\t\t4,\n\t\t\t\tnull,\n\t\t\t\tgl.UNSIGNED_BYTE,\n\t\t\t\ttrue,\n\t\t\t\t1\n\t\t\t),\n\t\t\tnew Mesh.Attrib(ShaderProgram.TEXCOORD_ATTRIBUTE + '0', 2)\n\t\t];\n\t},\n\n\t/**\n\t * Sets the projection vector, an x and y\n\t * defining the middle points of your stage.\n\t *\n\t * @method setProjection\n\t * @param {Number} x the x projection value\n\t * @param {Number} y the y projection value\n\t */\n\tsetProjection: function(mat4) {\n\t\tthis.projection = mat4;\n\t\tif (this.drawing && (x != oldX || y != oldY)) {\n\t\t\tthis.flush();\n\t\t\tthis.updateMatrices();\n\t\t}\n\t},\n\n\t/**\n\t * Creates a default shader for this batch.\n\t *\n\t * @method  _createShader\n\t * @protected\n\t * @return {ShaderProgram} a new instance of ShaderProgram\n\t */\n\t_createShader: function() {\n\t\tvar shader = new ShaderProgram(\n\t\t\tthis.context,\n\t\t\tSpriteBatch.DEFAULT_VERT_SHADER,\n\t\t\tSpriteBatch.DEFAULT_FRAG_SHADER\n\t\t);\n\t\tif (shader.log) console.warn('Shader Log:\\n' + shader.log);\n\t\treturn shader;\n\t},\n\n\t/**\n\t * This is called during rendering to update projection/transform\n\t * matrices and upload the new values to the shader. For example,\n\t * if the user calls setProjection mid-draw, the batch will flush\n\t * and this will be called before continuing to add items to the batch.\n\t *\n\t * You generally should not need to call this directly.\n\t * \n\t * @method  updateMatrices\n\t * @protected\n\t */\n\tupdateMatrices: function() {\n\t\tthis.shader.setUniformMatrix4('u_projection', this.projection);\n\t},\n\n\t/**\n\t * Called before rendering, and binds the current texture.\n\t * \n\t * @method _preRender\n\t * @protected\n\t */\n\t_preRender: function() {\n\t\tif (this.texture) this.texture.bind();\n\t},\n\n\t/**\n\t * Binds the shader, disables depth writing, \n\t * enables blending, activates texture unit 0, and sends\n\t * default matrices and sampler2D uniforms to the shader.\n\t *\n\t * @method  begin\n\t */\n\tbegin: function() {\n\t\t//sprite batch doesn't hold a reference to GL since it is volatile\n\t\tvar gl = this.context.gl;\n\n\t\t//This binds the shader and mesh!\n\t\tBaseBatch.prototype.begin.call(this);\n\n\t\tthis.updateMatrices(); //send projection/transform to shader\n\n\t\t//upload the sampler uniform. not necessary every flush so we just\n\t\t//do it here.\n\t\tthis.shader.setUniformi('u_texture0', 0);\n\n\t\t//disable depth mask\n\t\tgl.depthMask(false);\n\t},\n\n\t/**\n\t * Ends the sprite batcher and flushes any remaining data to the GPU.\n\t * \n\t * @method end\n\t */\n\tend: function() {\n\t\t//sprite batch doesn't hold a reference to GL since it is volatile\n\t\tvar gl = this.context.gl;\n\n\t\t//just do direct parent call for speed here\n\t\t//This binds the shader and mesh!\n\t\tBaseBatch.prototype.end.call(this);\n\n\t\tgl.depthMask(true);\n\t},\n\n\t/**\n\t * Flushes the batch to the GPU. This should be called when\n\t * state changes, such as blend functions, depth or stencil states,\n\t * shaders, and so forth.\n\t * \n\t * @method flush\n\t */\n\tflush: function() {\n\t\t//ignore flush if texture is null or our batch is empty\n\t\tif (!this.texture) return;\n\t\tif (this.idx === 0) return;\n\t\tBaseBatch.prototype.flush.call(this);\n\t\tSpriteBatch.totalRenderCalls++;\n\t},\n\n\tdrawRegion: function(region, x, y, width, height) {\n\t\tthis.draw(\n\t\t\tregion.texture,\n\t\t\tx,\n\t\t\ty,\n\t\t\twidth,\n\t\t\theight,\n\t\t\tregion.u,\n\t\t\tregion.v,\n\t\t\tregion.u2,\n\t\t\tregion.v2\n\t\t);\n\t},\n\n\t/**\n\t * Adds a sprite to this batch. The sprite is drawn in \n\t * screen-space with the origin at the upper-left corner (y-down).\n\t * \n\t * @method draw\n\t * @param  {Texture} texture the Texture\n\t * @param  {Number} x       the x position in pixels, defaults to zero\n\t * @param  {Number} y       the y position in pixels, defaults to zero\n\t * @param  {Number} width   the width in pixels, defaults to the texture width\n\t * @param  {Number} height  the height in pixels, defaults to the texture height\n\t * @param  {Number} u1      the first U coordinate, default zero\n\t * @param  {Number} v1      the first V coordinate, default zero\n\t * @param  {Number} u2      the second U coordinate, default one\n\t * @param  {Number} v2      the second V coordinate, default one\n\t */\n\tdraw: function(\n\t\ttexture,\n\t\tx,\n\t\ty,\n\t\twidth,\n\t\theight,\n\t\toriginX = 0,\n\t\toriginY = 0,\n\t\trotation = 0,\n\t\tscaleX = 1,\n\t\tscaleY = 1,\n\t\tu1 = 0,\n\t\tv1 = 0,\n\t\tu2 = 1,\n\t\tv2 = 1\n\t) {\n\t\tif (!this.drawing)\n\t\t\tthrow 'Illegal State: trying to draw a batch before begin()';\n\n\t\t//don't draw anything if GL tex doesn't exist..\n\t\tif (!texture) return;\n\n\t\tif (this.texture === null || this.texture.id !== texture.id) {\n\t\t\t//new texture.. flush previous data\n\t\t\tthis.flush();\n\t\t\tthis.texture = texture;\n\t\t} else if (this.idx == this.vertices.length) {\n\t\t\tthis.flush(); //we've reached our max, flush before pushing more data\n\t\t}\n\n\t\twidth = width === 0 ? width : width || texture.width;\n\t\theight = height === 0 ? height : height || texture.height;\n\t\tx = x || 0;\n\t\ty = y || 0;\n\n\t\tvar x1 = -originX;\n\t\tvar x2 = width - originX;\n\t\tvar x3 = width - originX;\n\t\tvar x4 = -originX;\n\n\t\tvar y1 = -originY;\n\t\tvar y2 = -originY;\n\t\tvar y3 = height - originY;\n\t\tvar y4 = height - originY;\n\n\t\tvar c = this.color;\n\n\t\tif (scaleX !== 1) {\n\t\t\tx1 = x1 * scaleX;\n\t\t\tx2 = x2 * scaleX;\n\t\t\tx3 = x3 * scaleX;\n\t\t\tx4 = x4 * scaleX;\n\t\t}\n\n\t\tif (scaleY !== 1) {\n\t\t\ty1 = y1 * scaleY;\n\t\t\ty2 = y2 * scaleY;\n\t\t\ty3 = y3 * scaleY;\n\t\t\ty4 = y4 * scaleY;\n\t\t}\n\n\t\tif (rotation !== 0) {\n\t\t\tvar cos = Math.cos(rotation);\n\t\t\tvar sin = Math.sin(rotation);\n\n\t\t\tvar rotatedX1 = cos * x1 - sin * y1;\n\t\t\tvar rotatedY1 = sin * x1 + cos * y1;\n\n\t\t\tvar rotatedX2 = cos * x2 - sin * y2;\n\t\t\tvar rotatedY2 = sin * x2 + cos * y2;\n\n\t\t\tvar rotatedX3 = cos * x3 - sin * y3;\n\t\t\tvar rotatedY3 = sin * x3 + cos * y3;\n\n\t\t\tvar rotatedX4 = cos * x4 - sin * y4;\n\t\t\tvar rotatedY4 = sin * x4 + cos * y4;\n\n\t\t\tx1 = rotatedX1;\n\t\t\tx2 = rotatedX2;\n\t\t\tx3 = rotatedX3;\n\t\t\tx4 = rotatedX4;\n\n\t\t\ty1 = rotatedY1;\n\t\t\ty2 = rotatedY2;\n\t\t\ty3 = rotatedY3;\n\t\t\ty4 = rotatedY4;\n\t\t}\n\n\t\tx1 += x + originX;\n\t\tx2 += x + originX;\n\t\tx3 += x + originX;\n\t\tx4 += x + originX;\n\n\t\ty1 += y + originY;\n\t\ty2 += y + originY;\n\t\ty3 += y + originY;\n\t\ty4 += y + originY;\n\n\t\t//xy\n\t\tthis.vertices[this.idx++] = x1;\n\t\tthis.vertices[this.idx++] = y1;\n\t\t//color\n\t\tthis.vertices[this.idx++] = c;\n\t\t//uv\n\t\tthis.vertices[this.idx++] = u1;\n\t\tthis.vertices[this.idx++] = v1;\n\n\t\t//xy\n\t\tthis.vertices[this.idx++] = x2;\n\t\tthis.vertices[this.idx++] = y2;\n\t\t//color\n\t\tthis.vertices[this.idx++] = c;\n\t\t//uv\n\t\tthis.vertices[this.idx++] = u2;\n\t\tthis.vertices[this.idx++] = v1;\n\n\t\t//xy\n\t\tthis.vertices[this.idx++] = x3;\n\t\tthis.vertices[this.idx++] = y3;\n\t\t//color\n\t\tthis.vertices[this.idx++] = c;\n\t\t//uv\n\t\tthis.vertices[this.idx++] = u2;\n\t\tthis.vertices[this.idx++] = v2;\n\n\t\t//xy\n\t\tthis.vertices[this.idx++] = x4;\n\t\tthis.vertices[this.idx++] = y4;\n\t\t//color\n\t\tthis.vertices[this.idx++] = c;\n\t\t//uv\n\t\tthis.vertices[this.idx++] = u1;\n\t\tthis.vertices[this.idx++] = v2;\n\t},\n\n\t/**\n\t * Adds a single quad mesh to this sprite batch from the given\n\t * array of vertices. The sprite is drawn in \n\t * screen-space with the origin at the upper-left corner (y-down).\n\t *\n\t * This reads 20 interleaved floats from the given offset index, in the format\n\t *\n\t *  { x, y, color, u, v,\n\t *      ...  }\n\t *\n\t * @method  drawVertices\n\t * @param {Texture} texture the Texture object\n\t * @param {Float32Array} verts an array of vertices\n\t * @param {Number} off the offset into the vertices array to read from\n\t */\n\tdrawVertices: function(texture, verts, off) {\n\t\tif (!this.drawing)\n\t\t\tthrow 'Illegal State: trying to draw a batch before begin()';\n\n\t\t//don't draw anything if GL tex doesn't exist..\n\t\tif (!texture) return;\n\n\t\tif (this.texture != texture) {\n\t\t\t//new texture.. flush previous data\n\t\t\tthis.flush();\n\t\t\tthis.texture = texture;\n\t\t} else if (this.idx == this.vertices.length) {\n\t\t\tthis.flush(); //we've reached our max, flush before pushing more data\n\t\t}\n\n\t\toff = off || 0;\n\t\t//TODO: use a loop here?\n\t\t//xy\n\t\tthis.vertices[this.idx++] = verts[off++];\n\t\tthis.vertices[this.idx++] = verts[off++];\n\t\t//color\n\t\tthis.vertices[this.idx++] = verts[off++];\n\t\t//uv\n\t\tthis.vertices[this.idx++] = verts[off++];\n\t\tthis.vertices[this.idx++] = verts[off++];\n\n\t\t//xy\n\t\tthis.vertices[this.idx++] = verts[off++];\n\t\tthis.vertices[this.idx++] = verts[off++];\n\t\t//color\n\t\tthis.vertices[this.idx++] = verts[off++];\n\t\t//uv\n\t\tthis.vertices[this.idx++] = verts[off++];\n\t\tthis.vertices[this.idx++] = verts[off++];\n\n\t\t//xy\n\t\tthis.vertices[this.idx++] = verts[off++];\n\t\tthis.vertices[this.idx++] = verts[off++];\n\t\t//color\n\t\tthis.vertices[this.idx++] = verts[off++];\n\t\t//uv\n\t\tthis.vertices[this.idx++] = verts[off++];\n\t\tthis.vertices[this.idx++] = verts[off++];\n\n\t\t//xy\n\t\tthis.vertices[this.idx++] = verts[off++];\n\t\tthis.vertices[this.idx++] = verts[off++];\n\t\t//color\n\t\tthis.vertices[this.idx++] = verts[off++];\n\t\t//uv\n\t\tthis.vertices[this.idx++] = verts[off++];\n\t\tthis.vertices[this.idx++] = verts[off++];\n\t}\n});\n\n/**\n * The default vertex size, i.e. number of floats per vertex.\n * @attribute  VERTEX_SIZE\n * @static\n * @final\n * @type {Number}\n * @default  5\n */\nSpriteBatch.VERTEX_SIZE = 5;\n\n/**\n * Incremented after each draw call, can be used for debugging.\n *\n *     SpriteBatch.totalRenderCalls = 0;\n *\n *     ... draw your scene ...\n *\n *     console.log(\"Draw calls per frame:\", SpriteBatch.totalRenderCalls);\n *\n * \n * @attribute  totalRenderCalls\n * @static\n * @type {Number}\n * @default  0\n */\nSpriteBatch.totalRenderCalls = 0;\n\nSpriteBatch.DEFAULT_FRAG_SHADER = [\n\t'precision mediump float;',\n\t'varying vec2 vTexCoord0;',\n\t'varying vec4 vColor;',\n\t'uniform sampler2D u_texture0;',\n\n\t'void main(void) {',\n\t'   gl_FragColor = texture2D(u_texture0, vTexCoord0) * vColor;',\n\t'}'\n].join('\\n');\n\nSpriteBatch.DEFAULT_VERT_SHADER = [\n\t'attribute vec4 ' + ShaderProgram.POSITION_ATTRIBUTE + ';',\n\t'attribute vec4 ' + ShaderProgram.COLOR_ATTRIBUTE + ';',\n\t'attribute vec2 ' + ShaderProgram.TEXCOORD_ATTRIBUTE + '0;',\n\n\t'uniform mat4 u_projection;',\n\t'varying vec2 vTexCoord0;',\n\t'varying vec4 vColor;',\n\n\t'void main(void) {', ///TODO: use a projection and transform matrix\n\t'   gl_Position =  u_projection * ' + ShaderProgram.POSITION_ATTRIBUTE + ';',\n\t'   vTexCoord0 = ' + ShaderProgram.TEXCOORD_ATTRIBUTE + '0;',\n\t'   vColor = ' + ShaderProgram.COLOR_ATTRIBUTE + ';',\n\t'   vColor.a = vColor.a * (256.0/255.0);', //this is so the alpha sits at 0.0 or 1.0\n\t'}'\n].join('\\n');\n\nmodule.exports = SpriteBatch;\n"]},"metadata":{},"sourceType":"script"}