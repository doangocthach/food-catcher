{"ast":null,"code":"var GLContextWrapper = require('./wrapper');\n\nfunction wrapContext(gl) {\n  //Chrome's WebGLInspector wraps it with a different class\n  //and then puts the original in 'rawgl' property\n  var rawgl = gl && gl.rawgl ? gl.rawgl : gl;\n\n  if (typeof window.WebGLRenderingContext !== \"undefined\" && rawgl instanceof window.WebGLRenderingContext) {\n    return new GLContextWrapper(gl);\n  } else return gl;\n}\n/**\n * Duck-types WebGLRenderingContext / kami.WebGLContext.\n *\n * If WebGLRenderingContext is passed, the object will not have its\n * state managed during context loss/restore. If a Kami WebGLContext\n * is passed, the object will try to maintain its state during lost/restore.\n * \n * @param  {WebGLRenderingContext|kami.WebGLContext} gl the GL context\n * @return {Object|kami.WebGLContext} a wrapper that has a `gl` property\n */\n\n\nmodule.exports.wrapContext = wrapContext;\n\nmodule.exports.BaseObject = function (context) {\n  if (!context || typeof context !== \"object\") throw \"valid GL context not specified\";\n  this.context = wrapContext(context);\n};","map":{"version":3,"sources":["E:/fcatcher-client/node_modules/kami-util/index.js"],"names":["GLContextWrapper","require","wrapContext","gl","rawgl","window","WebGLRenderingContext","module","exports","BaseObject","context"],"mappings":"AAAA,IAAIA,gBAAgB,GAAGC,OAAO,CAAC,WAAD,CAA9B;;AAEA,SAASC,WAAT,CAAqBC,EAArB,EAAyB;AACrB;AACA;AACA,MAAIC,KAAK,GAAGD,EAAE,IAAIA,EAAE,CAACC,KAAT,GAAiBD,EAAE,CAACC,KAApB,GAA4BD,EAAxC;;AACA,MAAI,OAAOE,MAAM,CAACC,qBAAd,KAAwC,WAAxC,IAAuDF,KAAK,YAAYC,MAAM,CAACC,qBAAnF,EAA0G;AACtG,WAAO,IAAIN,gBAAJ,CAAqBG,EAArB,CAAP;AACH,GAFD,MAGI,OAAOA,EAAP;AACP;AAED;;;;;;;;;;;;AAUAI,MAAM,CAACC,OAAP,CAAeN,WAAf,GAA6BA,WAA7B;;AAEAK,MAAM,CAACC,OAAP,CAAeC,UAAf,GAA4B,UAASC,OAAT,EAAkB;AAC1C,MAAI,CAACA,OAAD,IAAY,OAAOA,OAAP,KAAmB,QAAnC,EACI,MAAM,gCAAN;AAEJ,OAAKA,OAAL,GAAeR,WAAW,CAACQ,OAAD,CAA1B;AACH,CALD","sourcesContent":["var GLContextWrapper = require('./wrapper');\n\nfunction wrapContext(gl) {\n    //Chrome's WebGLInspector wraps it with a different class\n    //and then puts the original in 'rawgl' property\n    var rawgl = gl && gl.rawgl ? gl.rawgl : gl;\n    if (typeof window.WebGLRenderingContext !== \"undefined\" && rawgl instanceof window.WebGLRenderingContext) {\n        return new GLContextWrapper(gl);\n    } else\n        return gl;\n}\n\n/**\n * Duck-types WebGLRenderingContext / kami.WebGLContext.\n *\n * If WebGLRenderingContext is passed, the object will not have its\n * state managed during context loss/restore. If a Kami WebGLContext\n * is passed, the object will try to maintain its state during lost/restore.\n * \n * @param  {WebGLRenderingContext|kami.WebGLContext} gl the GL context\n * @return {Object|kami.WebGLContext} a wrapper that has a `gl` property\n */\nmodule.exports.wrapContext = wrapContext;\n\nmodule.exports.BaseObject = function(context) {\n    if (!context || typeof context !== \"object\")\n        throw \"valid GL context not specified\";\n\n    this.context = wrapContext(context);\n};"]},"metadata":{},"sourceType":"script"}