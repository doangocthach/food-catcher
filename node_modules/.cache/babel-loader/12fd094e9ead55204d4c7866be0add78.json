{"ast":null,"code":"import { Vector2 } from \"gdxjs\";\n\nconst checkKerning = (id1, id2, kerningsData) => {\n  let check = false;\n  let amount = 0;\n\n  for (let kerning of kerningsData) {\n    if (kerning.first === id1 && kerning.second === id2) {\n      amount = kerning.amount;\n      check = true;\n      break;\n    } else {\n      check = false;\n    }\n  }\n\n  if (check) {\n    return amount;\n  } else {\n    return 0;\n  }\n};\n\nexport default class GlyphLayour {\n  constructor(pageImage, regions, keringsData, canvasWidth) {\n    this.addToCache = (line, px, py, lineBreak, lineH) => {\n      let xAdvance = 0;\n\n      for (let index = 0; index < line.length; index++) {\n        const currChar = line.charCodeAt(index);\n        const preChar = line.charCodeAt(index - 1);\n        let key = this.findRegions(currChar);\n        let kerningAmount = checkKerning(preChar, currChar, this.kerningsData); // let kerningAmount = checkKerning(currChar, preChar, this.kerningsData);\n\n        this.cache.push({\n          key: key,\n          x: px + xAdvance + key.xoffset * this.scale + kerningAmount * this.scale,\n          y: py + key.yoffset * this.scale + lineBreak * this.scale + lineH,\n          width: key.width * this.scale,\n          height: key.height * this.scale\n        });\n        xAdvance += key.xadvance * this.scale;\n      }\n    };\n\n    this.beforeDrawing = (posX, posY, fontSize, CharSequence) => {\n      if (this.preDraw) {\n        let spaceXadvance = 0;\n        let tmpLength = 0;\n        let tmplist = []; // find longest sequence\n\n        for (let i = 0; i < CharSequence.length; i++) {\n          const char = CharSequence.charCodeAt(i);\n          const key = this.findRegions(char);\n\n          if (char !== 32) {\n            tmpLength += key.xadvance * this.scale;\n          } else {\n            spaceXadvance = key.xadvance * this.scale;\n            tmplist.push(tmpLength);\n            tmpLength = 0;\n          }\n        }\n\n        let maxSeq = Math.max(...tmplist) + spaceXadvance; //////////////////\n\n        this.newbase = fontSize;\n        this.scale = this.newbase / this.baseLine;\n        CharSequence = CharSequence.trim(); // split string between /n\n\n        let listCharSeq = CharSequence.split(\"/n\").map(s => s.trim());\n        let lineH = 0;\n\n        for (let si = 0; si < listCharSeq.length; si++) {\n          CharSequence = listCharSeq[si]; // find new origin Width for each line\n\n          this.oriWidth = 0;\n\n          for (let i = 0; i < CharSequence.length; i++) {\n            const char = CharSequence.charCodeAt(i);\n            const preChar = CharSequence.charCodeAt(i - 1);\n            const key = this.findRegions(char);\n            let kerningAmount = checkKerning(preChar, char, this.kerningsData); // new\n\n            this.oriWidth += kerningAmount * this.scale; // new\n\n            if (i < CharSequence.length - 1) {\n              this.oriWidth += key.xadvance * this.scale;\n            } else {\n              this.oriWidth += key.width * this.scale;\n            }\n          }\n\n          let tmpRatio = this.oriWidth / this.fixedWidth;\n          lineH = this.lineHeight * this.scale * si;\n          let accumulate = 0;\n          let tmpChar = \"\";\n          let lineBreak = 0; // finding position break and length of each line\n          // only execute if oriWidth > fixedWidth and fixedWidth > longest seq\n\n          if (tmpRatio > 1 && this.fixedWidth > maxSeq) {\n            for (let i = 0; i < CharSequence.length; i++) {\n              tmpChar += CharSequence[i];\n              const char = CharSequence.charCodeAt(i);\n              const key = this.findRegions(char);\n              accumulate += key.xadvance * this.scale; // every line before last line\n\n              if (accumulate >= this.fixedWidth) {\n                let j = i;\n\n                while (j >= 0) {\n                  i--;\n                  j--;\n                  const key2 = this.findRegions(CharSequence.charCodeAt(i));\n                  accumulate -= key2.xadvance * this.scale;\n                  tmpChar = tmpChar.substring(0, tmpChar.length - 1);\n\n                  if (accumulate <= this.fixedWidth && key2.id === 32) {\n                    lineBreak = this.lineHeight * this.positionBreak.length;\n                    this.positionBreak.push(i); ///\n\n                    this.lastBreakIndex = i;\n                    const line = tmpChar.trim();\n                    let tmp = 0;\n                    let key3 = 0;\n\n                    for (let index = 0; index < line.length; index++) {\n                      key3 = this.findRegions(line.charCodeAt(index));\n\n                      if (index === line.length - 1) {\n                        tmp += key3.width * this.scale;\n                      } else {\n                        tmp += key3.xadvance * this.scale;\n                      }\n                    }\n\n                    let [px, py] = this.getPositionBasedOnMode(posX, posY, tmp);\n                    this.addToCache(line, px, py, lineBreak, lineH);\n                    accumulate = 0;\n                    j = -1;\n                    tmpChar = \"\";\n                  }\n                }\n              } // last line\n\n\n              if (i === CharSequence.length - 1 && accumulate < this.oriWidth) {\n                let tmpChar = \"\";\n\n                for (let j = this.lastBreakIndex; j <= i; j++) {\n                  tmpChar += CharSequence[j];\n                }\n\n                const lastLine = tmpChar.trim();\n                let tmpXadvance = 0;\n                let lastKey = 0;\n\n                for (let index = 0; index < lastLine.length; index++) {\n                  lastKey = this.findRegions(lastLine.charCodeAt(index));\n\n                  if (index === lastLine.length - 1) {\n                    tmpXadvance += lastKey.width * this.scale;\n                  } else {\n                    tmpXadvance += lastKey.xadvance * this.scale;\n                  }\n                }\n\n                let [px, py] = this.getPositionBasedOnMode(posX, posY, tmpXadvance);\n                lineBreak = this.lineHeight * this.positionBreak.length;\n                this.addToCache(lastLine, px, py, lineBreak, lineH);\n              }\n            }\n          } // if originWidth < fixedWidth or fixedWidth < longest sequence\n\n\n          if (tmpRatio <= 1 || this.fixedWidth < maxSeq) {\n            let [px, py] = this.getPositionBasedOnMode(posX, posY, this.oriWidth);\n            this.addToCache(CharSequence, px, py, 0, lineH);\n          }\n        }\n\n        if (this.type === 0) {\n          this.preDraw = false;\n        }\n\n        this.oriHeight = this.newbase;\n      }\n    };\n\n    this.getPositionBasedOnMode = (posX, posY, oriWidth) => {\n      if (this.align === 0) {\n        // posY -= Math.round(this.oriHeight / 2);\n        posX -= Math.round(oriWidth / 2);\n      } else if (this.align === 1) {\n        posX -= oriWidth;\n      }\n\n      return [posX, posY];\n    };\n\n    this.setAlignMode = mode => {\n      this.align = mode;\n    };\n\n    this.setType = type => {\n      this.type = type;\n    };\n\n    this.setLineHeight = lineHeight => {\n      this.lineHeight = lineHeight;\n    };\n\n    this.setFixedGlyphWidth = fixedW => {\n      this.fixedWidth = fixedW; // this.fixedHeight = fixedH;\n    };\n\n    this.findRegions = id => {\n      for (let i = 0; i < this.regions.length; i++) {\n        if (this.regions[i].id === id) {\n          return this.regions[i];\n        }\n      }\n    };\n\n    this.draw = (batch, CharSequence = \"\", posX, posY, fontSize = this.baseLine) => {\n      if (this.type === 0) {\n        if (this.preDraw) {\n          this.beforeDrawing(posX, posY, fontSize, CharSequence);\n        }\n\n        for (let i = 0; i < this.cache.length; i++) {\n          let cache = this.cache[i];\n          cache.key.draw(batch, cache.x, cache.y, cache.width, cache.height);\n        }\n      }\n\n      if (this.type === 1) {\n        this.beforeDrawing(posX, posY, fontSize, CharSequence);\n\n        for (let i = 0; i < this.cache.length; i++) {\n          let cache = this.cache[i];\n          cache.key.draw(batch, cache.x, cache.y, cache.width, cache.height);\n        }\n\n        this.cache.length = 0;\n        this.positionBreak.length = 0;\n      }\n    };\n\n    this.pageImage = pageImage;\n    this.regions = regions;\n    this.kerningsData = keringsData;\n    this.canvasWidth = canvasWidth;\n    this.type = 0;\n    this.align = 2;\n    this.lineHeight = pageImage.lineHeight;\n    this.baseLine = pageImage.base;\n    this.fixedWidth = canvasWidth; // temp variable\n\n    this.position = new Vector2(0, 0);\n    this.scale = 0;\n    this.newBase = 0;\n    this.oriWidth = 0;\n    this.oriHeight = 0;\n    this.positionBreak = []; // list of break-position's index\n\n    this.lastBreakIndex = 0; // pre draw\n\n    this.cache = [];\n    this.preDraw = true;\n  }\n\n}","map":{"version":3,"sources":["E:/fcatcher-client/src/components/game/utils/glyphLayout.js"],"names":["Vector2","checkKerning","id1","id2","kerningsData","check","amount","kerning","first","second","GlyphLayour","constructor","pageImage","regions","keringsData","canvasWidth","addToCache","line","px","py","lineBreak","lineH","xAdvance","index","length","currChar","charCodeAt","preChar","key","findRegions","kerningAmount","cache","push","x","xoffset","scale","y","yoffset","width","height","xadvance","beforeDrawing","posX","posY","fontSize","CharSequence","preDraw","spaceXadvance","tmpLength","tmplist","i","char","maxSeq","Math","max","newbase","baseLine","trim","listCharSeq","split","map","s","si","oriWidth","tmpRatio","fixedWidth","lineHeight","accumulate","tmpChar","j","key2","substring","id","positionBreak","lastBreakIndex","tmp","key3","getPositionBasedOnMode","lastLine","tmpXadvance","lastKey","type","oriHeight","align","round","setAlignMode","mode","setType","setLineHeight","setFixedGlyphWidth","fixedW","draw","batch","base","position","newBase"],"mappings":"AAAA,SAASA,OAAT,QAAwB,OAAxB;;AAEA,MAAMC,YAAY,GAAG,CAACC,GAAD,EAAMC,GAAN,EAAWC,YAAX,KAA4B;AAC/C,MAAIC,KAAK,GAAG,KAAZ;AACA,MAAIC,MAAM,GAAG,CAAb;;AACA,OAAK,IAAIC,OAAT,IAAoBH,YAApB,EAAkC;AAChC,QAAIG,OAAO,CAACC,KAAR,KAAkBN,GAAlB,IAAyBK,OAAO,CAACE,MAAR,KAAmBN,GAAhD,EAAqD;AACnDG,MAAAA,MAAM,GAAGC,OAAO,CAACD,MAAjB;AACAD,MAAAA,KAAK,GAAG,IAAR;AACA;AACD,KAJD,MAIO;AACLA,MAAAA,KAAK,GAAG,KAAR;AACD;AACF;;AACD,MAAIA,KAAJ,EAAW;AACT,WAAOC,MAAP;AACD,GAFD,MAEO;AACL,WAAO,CAAP;AACD;AACF,CAjBD;;AAmBA,eAAe,MAAMI,WAAN,CAAkB;AAC/BC,EAAAA,WAAW,CAACC,SAAD,EAAYC,OAAZ,EAAqBC,WAArB,EAAkCC,WAAlC,EAA+C;AAAA,SAsB1DC,UAtB0D,GAsB7C,CAACC,IAAD,EAAOC,EAAP,EAAWC,EAAX,EAAeC,SAAf,EAA0BC,KAA1B,KAAoC;AAC/C,UAAIC,QAAQ,GAAG,CAAf;;AACA,WAAK,IAAIC,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGN,IAAI,CAACO,MAAjC,EAAyCD,KAAK,EAA9C,EAAkD;AAChD,cAAME,QAAQ,GAAGR,IAAI,CAACS,UAAL,CAAgBH,KAAhB,CAAjB;AACA,cAAMI,OAAO,GAAGV,IAAI,CAACS,UAAL,CAAgBH,KAAK,GAAG,CAAxB,CAAhB;AACA,YAAIK,GAAG,GAAG,KAAKC,WAAL,CAAiBJ,QAAjB,CAAV;AACA,YAAIK,aAAa,GAAG7B,YAAY,CAAC0B,OAAD,EAAUF,QAAV,EAAoB,KAAKrB,YAAzB,CAAhC,CAJgD,CAKhD;;AACA,aAAK2B,KAAL,CAAWC,IAAX,CAAgB;AACdJ,UAAAA,GAAG,EAAEA,GADS;AAEdK,UAAAA,CAAC,EACCf,EAAE,GAAGI,QAAL,GAAgBM,GAAG,CAACM,OAAJ,GAAc,KAAKC,KAAnC,GAA2CL,aAAa,GAAG,KAAKK,KAHpD;AAIdC,UAAAA,CAAC,EAAEjB,EAAE,GAAGS,GAAG,CAACS,OAAJ,GAAc,KAAKF,KAAxB,GAAgCf,SAAS,GAAG,KAAKe,KAAjD,GAAyDd,KAJ9C;AAKdiB,UAAAA,KAAK,EAAEV,GAAG,CAACU,KAAJ,GAAY,KAAKH,KALV;AAMdI,UAAAA,MAAM,EAAEX,GAAG,CAACW,MAAJ,GAAa,KAAKJ;AANZ,SAAhB;AAQAb,QAAAA,QAAQ,IAAIM,GAAG,CAACY,QAAJ,GAAe,KAAKL,KAAhC;AACD;AACF,KAxCyD;;AAAA,SA0C1DM,aA1C0D,GA0C1C,CAACC,IAAD,EAAOC,IAAP,EAAaC,QAAb,EAAuBC,YAAvB,KAAwC;AACtD,UAAI,KAAKC,OAAT,EAAkB;AAChB,YAAIC,aAAa,GAAG,CAApB;AACA,YAAIC,SAAS,GAAG,CAAhB;AACA,YAAIC,OAAO,GAAG,EAAd,CAHgB,CAIhB;;AACA,aAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,YAAY,CAACrB,MAAjC,EAAyC0B,CAAC,EAA1C,EAA8C;AAC5C,gBAAMC,IAAI,GAAGN,YAAY,CAACnB,UAAb,CAAwBwB,CAAxB,CAAb;AACA,gBAAMtB,GAAG,GAAG,KAAKC,WAAL,CAAiBsB,IAAjB,CAAZ;;AACA,cAAIA,IAAI,KAAK,EAAb,EAAiB;AACfH,YAAAA,SAAS,IAAIpB,GAAG,CAACY,QAAJ,GAAe,KAAKL,KAAjC;AACD,WAFD,MAEO;AACLY,YAAAA,aAAa,GAAGnB,GAAG,CAACY,QAAJ,GAAe,KAAKL,KAApC;AACAc,YAAAA,OAAO,CAACjB,IAAR,CAAagB,SAAb;AACAA,YAAAA,SAAS,GAAG,CAAZ;AACD;AACF;;AACD,YAAII,MAAM,GAAGC,IAAI,CAACC,GAAL,CAAS,GAAGL,OAAZ,IAAuBF,aAApC,CAhBgB,CAiBhB;;AACA,aAAKQ,OAAL,GAAeX,QAAf;AACA,aAAKT,KAAL,GAAa,KAAKoB,OAAL,GAAe,KAAKC,QAAjC;AACAX,QAAAA,YAAY,GAAGA,YAAY,CAACY,IAAb,EAAf,CApBgB,CAsBhB;;AACA,YAAIC,WAAW,GAAGb,YAAY,CAACc,KAAb,CAAmB,IAAnB,EAAyBC,GAAzB,CAA8BC,CAAD,IAAOA,CAAC,CAACJ,IAAF,EAApC,CAAlB;AACA,YAAIpC,KAAK,GAAG,CAAZ;;AACA,aAAK,IAAIyC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGJ,WAAW,CAAClC,MAAlC,EAA0CsC,EAAE,EAA5C,EAAgD;AAC9CjB,UAAAA,YAAY,GAAGa,WAAW,CAACI,EAAD,CAA1B,CAD8C,CAE9C;;AACA,eAAKC,QAAL,GAAgB,CAAhB;;AACA,eAAK,IAAIb,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,YAAY,CAACrB,MAAjC,EAAyC0B,CAAC,EAA1C,EAA8C;AAC5C,kBAAMC,IAAI,GAAGN,YAAY,CAACnB,UAAb,CAAwBwB,CAAxB,CAAb;AACA,kBAAMvB,OAAO,GAAGkB,YAAY,CAACnB,UAAb,CAAwBwB,CAAC,GAAG,CAA5B,CAAhB;AACA,kBAAMtB,GAAG,GAAG,KAAKC,WAAL,CAAiBsB,IAAjB,CAAZ;AACA,gBAAIrB,aAAa,GAAG7B,YAAY,CAAC0B,OAAD,EAAUwB,IAAV,EAAgB,KAAK/C,YAArB,CAAhC,CAJ4C,CAIwB;;AACpE,iBAAK2D,QAAL,IAAiBjC,aAAa,GAAG,KAAKK,KAAtC,CAL4C,CAKC;;AAC7C,gBAAIe,CAAC,GAAGL,YAAY,CAACrB,MAAb,GAAsB,CAA9B,EAAiC;AAC/B,mBAAKuC,QAAL,IAAiBnC,GAAG,CAACY,QAAJ,GAAe,KAAKL,KAArC;AACD,aAFD,MAEO;AACL,mBAAK4B,QAAL,IAAiBnC,GAAG,CAACU,KAAJ,GAAY,KAAKH,KAAlC;AACD;AACF;;AACD,cAAI6B,QAAQ,GAAG,KAAKD,QAAL,GAAgB,KAAKE,UAApC;AACA5C,UAAAA,KAAK,GAAG,KAAK6C,UAAL,GAAkB,KAAK/B,KAAvB,GAA+B2B,EAAvC;AACA,cAAIK,UAAU,GAAG,CAAjB;AACA,cAAIC,OAAO,GAAG,EAAd;AACA,cAAIhD,SAAS,GAAG,CAAhB,CApB8C,CAqB9C;AACA;;AACA,cAAI4C,QAAQ,GAAG,CAAX,IAAgB,KAAKC,UAAL,GAAkBb,MAAtC,EAA8C;AAC5C,iBAAK,IAAIF,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,YAAY,CAACrB,MAAjC,EAAyC0B,CAAC,EAA1C,EAA8C;AAC5CkB,cAAAA,OAAO,IAAIvB,YAAY,CAACK,CAAD,CAAvB;AACA,oBAAMC,IAAI,GAAGN,YAAY,CAACnB,UAAb,CAAwBwB,CAAxB,CAAb;AACA,oBAAMtB,GAAG,GAAG,KAAKC,WAAL,CAAiBsB,IAAjB,CAAZ;AACAgB,cAAAA,UAAU,IAAIvC,GAAG,CAACY,QAAJ,GAAe,KAAKL,KAAlC,CAJ4C,CAK5C;;AACA,kBAAIgC,UAAU,IAAI,KAAKF,UAAvB,EAAmC;AACjC,oBAAII,CAAC,GAAGnB,CAAR;;AACA,uBAAOmB,CAAC,IAAI,CAAZ,EAAe;AACbnB,kBAAAA,CAAC;AACDmB,kBAAAA,CAAC;AACD,wBAAMC,IAAI,GAAG,KAAKzC,WAAL,CAAiBgB,YAAY,CAACnB,UAAb,CAAwBwB,CAAxB,CAAjB,CAAb;AACAiB,kBAAAA,UAAU,IAAIG,IAAI,CAAC9B,QAAL,GAAgB,KAAKL,KAAnC;AACAiC,kBAAAA,OAAO,GAAGA,OAAO,CAACG,SAAR,CAAkB,CAAlB,EAAqBH,OAAO,CAAC5C,MAAR,GAAiB,CAAtC,CAAV;;AACA,sBAAI2C,UAAU,IAAI,KAAKF,UAAnB,IAAiCK,IAAI,CAACE,EAAL,KAAY,EAAjD,EAAqD;AACnDpD,oBAAAA,SAAS,GAAG,KAAK8C,UAAL,GAAkB,KAAKO,aAAL,CAAmBjD,MAAjD;AACA,yBAAKiD,aAAL,CAAmBzC,IAAnB,CAAwBkB,CAAxB,EAFmD,CAEvB;;AAC5B,yBAAKwB,cAAL,GAAsBxB,CAAtB;AACA,0BAAMjC,IAAI,GAAGmD,OAAO,CAACX,IAAR,EAAb;AACA,wBAAIkB,GAAG,GAAG,CAAV;AACA,wBAAIC,IAAI,GAAG,CAAX;;AAEA,yBAAK,IAAIrD,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGN,IAAI,CAACO,MAAjC,EAAyCD,KAAK,EAA9C,EAAkD;AAChDqD,sBAAAA,IAAI,GAAG,KAAK/C,WAAL,CAAiBZ,IAAI,CAACS,UAAL,CAAgBH,KAAhB,CAAjB,CAAP;;AACA,0BAAIA,KAAK,KAAKN,IAAI,CAACO,MAAL,GAAc,CAA5B,EAA+B;AAC7BmD,wBAAAA,GAAG,IAAIC,IAAI,CAACtC,KAAL,GAAa,KAAKH,KAAzB;AACD,uBAFD,MAEO;AACLwC,wBAAAA,GAAG,IAAIC,IAAI,CAACpC,QAAL,GAAgB,KAAKL,KAA5B;AACD;AACF;;AACD,wBAAI,CAACjB,EAAD,EAAKC,EAAL,IAAW,KAAK0D,sBAAL,CAA4BnC,IAA5B,EAAkCC,IAAlC,EAAwCgC,GAAxC,CAAf;AAEA,yBAAK3D,UAAL,CAAgBC,IAAhB,EAAsBC,EAAtB,EAA0BC,EAA1B,EAA8BC,SAA9B,EAAyCC,KAAzC;AAEA8C,oBAAAA,UAAU,GAAG,CAAb;AACAE,oBAAAA,CAAC,GAAG,CAAC,CAAL;AACAD,oBAAAA,OAAO,GAAG,EAAV;AACD;AACF;AACF,eAvC2C,CAwC5C;;;AACA,kBAAIlB,CAAC,KAAKL,YAAY,CAACrB,MAAb,GAAsB,CAA5B,IAAiC2C,UAAU,GAAG,KAAKJ,QAAvD,EAAiE;AAC/D,oBAAIK,OAAO,GAAG,EAAd;;AACA,qBAAK,IAAIC,CAAC,GAAG,KAAKK,cAAlB,EAAkCL,CAAC,IAAInB,CAAvC,EAA0CmB,CAAC,EAA3C,EAA+C;AAC7CD,kBAAAA,OAAO,IAAIvB,YAAY,CAACwB,CAAD,CAAvB;AACD;;AACD,sBAAMS,QAAQ,GAAGV,OAAO,CAACX,IAAR,EAAjB;AACA,oBAAIsB,WAAW,GAAG,CAAlB;AACA,oBAAIC,OAAO,GAAG,CAAd;;AACA,qBAAK,IAAIzD,KAAK,GAAG,CAAjB,EAAoBA,KAAK,GAAGuD,QAAQ,CAACtD,MAArC,EAA6CD,KAAK,EAAlD,EAAsD;AACpDyD,kBAAAA,OAAO,GAAG,KAAKnD,WAAL,CAAiBiD,QAAQ,CAACpD,UAAT,CAAoBH,KAApB,CAAjB,CAAV;;AACA,sBAAIA,KAAK,KAAKuD,QAAQ,CAACtD,MAAT,GAAkB,CAAhC,EAAmC;AACjCuD,oBAAAA,WAAW,IAAIC,OAAO,CAAC1C,KAAR,GAAgB,KAAKH,KAApC;AACD,mBAFD,MAEO;AACL4C,oBAAAA,WAAW,IAAIC,OAAO,CAACxC,QAAR,GAAmB,KAAKL,KAAvC;AACD;AACF;;AACD,oBAAI,CAACjB,EAAD,EAAKC,EAAL,IAAW,KAAK0D,sBAAL,CACbnC,IADa,EAEbC,IAFa,EAGboC,WAHa,CAAf;AAKA3D,gBAAAA,SAAS,GAAG,KAAK8C,UAAL,GAAkB,KAAKO,aAAL,CAAmBjD,MAAjD;AACA,qBAAKR,UAAL,CAAgB8D,QAAhB,EAA0B5D,EAA1B,EAA8BC,EAA9B,EAAkCC,SAAlC,EAA6CC,KAA7C;AACD;AACF;AACF,WA1F6C,CA2F9C;;;AACA,cAAI2C,QAAQ,IAAI,CAAZ,IAAiB,KAAKC,UAAL,GAAkBb,MAAvC,EAA+C;AAC7C,gBAAI,CAAClC,EAAD,EAAKC,EAAL,IAAW,KAAK0D,sBAAL,CAA4BnC,IAA5B,EAAkCC,IAAlC,EAAwC,KAAKoB,QAA7C,CAAf;AACA,iBAAK/C,UAAL,CAAgB6B,YAAhB,EAA8B3B,EAA9B,EAAkCC,EAAlC,EAAsC,CAAtC,EAAyCE,KAAzC;AACD;AACF;;AACD,YAAI,KAAK4D,IAAL,KAAc,CAAlB,EAAqB;AACnB,eAAKnC,OAAL,GAAe,KAAf;AACD;;AACD,aAAKoC,SAAL,GAAiB,KAAK3B,OAAtB;AACD;AACF,KA1KyD;;AAAA,SA4K1DsB,sBA5K0D,GA4KjC,CAACnC,IAAD,EAAOC,IAAP,EAAaoB,QAAb,KAA0B;AACjD,UAAI,KAAKoB,KAAL,KAAe,CAAnB,EAAsB;AACpB;AACAzC,QAAAA,IAAI,IAAIW,IAAI,CAAC+B,KAAL,CAAWrB,QAAQ,GAAG,CAAtB,CAAR;AACD,OAHD,MAGO,IAAI,KAAKoB,KAAL,KAAe,CAAnB,EAAsB;AAC3BzC,QAAAA,IAAI,IAAIqB,QAAR;AACD;;AACD,aAAO,CAACrB,IAAD,EAAOC,IAAP,CAAP;AACD,KApLyD;;AAAA,SAsL1D0C,YAtL0D,GAsL1CC,IAAD,IAAU;AACvB,WAAKH,KAAL,GAAaG,IAAb;AACD,KAxLyD;;AAAA,SA0L1DC,OA1L0D,GA0L/CN,IAAD,IAAU;AAClB,WAAKA,IAAL,GAAYA,IAAZ;AACD,KA5LyD;;AAAA,SA8L1DO,aA9L0D,GA8LzCtB,UAAD,IAAgB;AAC9B,WAAKA,UAAL,GAAkBA,UAAlB;AACD,KAhMyD;;AAAA,SAkM1DuB,kBAlM0D,GAkMpCC,MAAD,IAAY;AAC/B,WAAKzB,UAAL,GAAkByB,MAAlB,CAD+B,CAE/B;AACD,KArMyD;;AAAA,SAuM1D7D,WAvM0D,GAuM3C2C,EAAD,IAAQ;AACpB,WAAK,IAAItB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKrC,OAAL,CAAaW,MAAjC,EAAyC0B,CAAC,EAA1C,EAA8C;AAC5C,YAAI,KAAKrC,OAAL,CAAaqC,CAAb,EAAgBsB,EAAhB,KAAuBA,EAA3B,EAA+B;AAC7B,iBAAO,KAAK3D,OAAL,CAAaqC,CAAb,CAAP;AACD;AACF;AACF,KA7MyD;;AAAA,SA+M1DyC,IA/M0D,GA+MnD,CAACC,KAAD,EAAQ/C,YAAY,GAAG,EAAvB,EAA2BH,IAA3B,EAAiCC,IAAjC,EAAuCC,QAAQ,GAAG,KAAKY,QAAvD,KAAoE;AACzE,UAAI,KAAKyB,IAAL,KAAc,CAAlB,EAAqB;AACnB,YAAI,KAAKnC,OAAT,EAAkB;AAChB,eAAKL,aAAL,CAAmBC,IAAnB,EAAyBC,IAAzB,EAA+BC,QAA/B,EAAyCC,YAAzC;AACD;;AACD,aAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKnB,KAAL,CAAWP,MAA/B,EAAuC0B,CAAC,EAAxC,EAA4C;AAC1C,cAAInB,KAAK,GAAG,KAAKA,KAAL,CAAWmB,CAAX,CAAZ;AACAnB,UAAAA,KAAK,CAACH,GAAN,CAAU+D,IAAV,CAAeC,KAAf,EAAsB7D,KAAK,CAACE,CAA5B,EAA+BF,KAAK,CAACK,CAArC,EAAwCL,KAAK,CAACO,KAA9C,EAAqDP,KAAK,CAACQ,MAA3D;AACD;AACF;;AAED,UAAI,KAAK0C,IAAL,KAAc,CAAlB,EAAqB;AACnB,aAAKxC,aAAL,CAAmBC,IAAnB,EAAyBC,IAAzB,EAA+BC,QAA/B,EAAyCC,YAAzC;;AACA,aAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKnB,KAAL,CAAWP,MAA/B,EAAuC0B,CAAC,EAAxC,EAA4C;AAC1C,cAAInB,KAAK,GAAG,KAAKA,KAAL,CAAWmB,CAAX,CAAZ;AACAnB,UAAAA,KAAK,CAACH,GAAN,CAAU+D,IAAV,CAAeC,KAAf,EAAsB7D,KAAK,CAACE,CAA5B,EAA+BF,KAAK,CAACK,CAArC,EAAwCL,KAAK,CAACO,KAA9C,EAAqDP,KAAK,CAACQ,MAA3D;AACD;;AACD,aAAKR,KAAL,CAAWP,MAAX,GAAoB,CAApB;AACA,aAAKiD,aAAL,CAAmBjD,MAAnB,GAA4B,CAA5B;AACD;AACF,KAnOyD;;AACxD,SAAKZ,SAAL,GAAiBA,SAAjB;AACA,SAAKC,OAAL,GAAeA,OAAf;AACA,SAAKT,YAAL,GAAoBU,WAApB;AACA,SAAKC,WAAL,GAAmBA,WAAnB;AACA,SAAKkE,IAAL,GAAY,CAAZ;AACA,SAAKE,KAAL,GAAa,CAAb;AACA,SAAKjB,UAAL,GAAkBtD,SAAS,CAACsD,UAA5B;AACA,SAAKV,QAAL,GAAgB5C,SAAS,CAACiF,IAA1B;AACA,SAAK5B,UAAL,GAAkBlD,WAAlB,CATwD,CAUxD;;AACA,SAAK+E,QAAL,GAAgB,IAAI9F,OAAJ,CAAY,CAAZ,EAAe,CAAf,CAAhB;AACA,SAAKmC,KAAL,GAAa,CAAb;AACA,SAAK4D,OAAL,GAAe,CAAf;AACA,SAAKhC,QAAL,GAAgB,CAAhB;AACA,SAAKmB,SAAL,GAAiB,CAAjB;AACA,SAAKT,aAAL,GAAqB,EAArB,CAhBwD,CAgB/B;;AACzB,SAAKC,cAAL,GAAsB,CAAtB,CAjBwD,CAkBxD;;AACA,SAAK3C,KAAL,GAAa,EAAb;AACA,SAAKe,OAAL,GAAe,IAAf;AACD;;AAtB8B","sourcesContent":["import { Vector2 } from \"gdxjs\";\r\n\r\nconst checkKerning = (id1, id2, kerningsData) => {\r\n  let check = false;\r\n  let amount = 0;\r\n  for (let kerning of kerningsData) {\r\n    if (kerning.first === id1 && kerning.second === id2) {\r\n      amount = kerning.amount;\r\n      check = true;\r\n      break;\r\n    } else {\r\n      check = false;\r\n    }\r\n  }\r\n  if (check) {\r\n    return amount;\r\n  } else {\r\n    return 0;\r\n  }\r\n};\r\n\r\nexport default class GlyphLayour {\r\n  constructor(pageImage, regions, keringsData, canvasWidth) {\r\n    this.pageImage = pageImage;\r\n    this.regions = regions;\r\n    this.kerningsData = keringsData;\r\n    this.canvasWidth = canvasWidth;\r\n    this.type = 0;\r\n    this.align = 2;\r\n    this.lineHeight = pageImage.lineHeight;\r\n    this.baseLine = pageImage.base;\r\n    this.fixedWidth = canvasWidth;\r\n    // temp variable\r\n    this.position = new Vector2(0, 0);\r\n    this.scale = 0;\r\n    this.newBase = 0;\r\n    this.oriWidth = 0;\r\n    this.oriHeight = 0;\r\n    this.positionBreak = []; // list of break-position's index\r\n    this.lastBreakIndex = 0;\r\n    // pre draw\r\n    this.cache = [];\r\n    this.preDraw = true;\r\n  }\r\n  addToCache = (line, px, py, lineBreak, lineH) => {\r\n    let xAdvance = 0;\r\n    for (let index = 0; index < line.length; index++) {\r\n      const currChar = line.charCodeAt(index);\r\n      const preChar = line.charCodeAt(index - 1);\r\n      let key = this.findRegions(currChar);\r\n      let kerningAmount = checkKerning(preChar, currChar, this.kerningsData);\r\n      // let kerningAmount = checkKerning(currChar, preChar, this.kerningsData);\r\n      this.cache.push({\r\n        key: key,\r\n        x:\r\n          px + xAdvance + key.xoffset * this.scale + kerningAmount * this.scale,\r\n        y: py + key.yoffset * this.scale + lineBreak * this.scale + lineH,\r\n        width: key.width * this.scale,\r\n        height: key.height * this.scale,\r\n      });\r\n      xAdvance += key.xadvance * this.scale;\r\n    }\r\n  };\r\n\r\n  beforeDrawing = (posX, posY, fontSize, CharSequence) => {\r\n    if (this.preDraw) {\r\n      let spaceXadvance = 0;\r\n      let tmpLength = 0;\r\n      let tmplist = [];\r\n      // find longest sequence\r\n      for (let i = 0; i < CharSequence.length; i++) {\r\n        const char = CharSequence.charCodeAt(i);\r\n        const key = this.findRegions(char);\r\n        if (char !== 32) {\r\n          tmpLength += key.xadvance * this.scale;\r\n        } else {\r\n          spaceXadvance = key.xadvance * this.scale;\r\n          tmplist.push(tmpLength);\r\n          tmpLength = 0;\r\n        }\r\n      }\r\n      let maxSeq = Math.max(...tmplist) + spaceXadvance;\r\n      //////////////////\r\n      this.newbase = fontSize;\r\n      this.scale = this.newbase / this.baseLine;\r\n      CharSequence = CharSequence.trim();\r\n\r\n      // split string between /n\r\n      let listCharSeq = CharSequence.split(\"/n\").map((s) => s.trim());\r\n      let lineH = 0;\r\n      for (let si = 0; si < listCharSeq.length; si++) {\r\n        CharSequence = listCharSeq[si];\r\n        // find new origin Width for each line\r\n        this.oriWidth = 0;\r\n        for (let i = 0; i < CharSequence.length; i++) {\r\n          const char = CharSequence.charCodeAt(i);\r\n          const preChar = CharSequence.charCodeAt(i - 1);\r\n          const key = this.findRegions(char);\r\n          let kerningAmount = checkKerning(preChar, char, this.kerningsData); // new\r\n          this.oriWidth += kerningAmount * this.scale; // new\r\n          if (i < CharSequence.length - 1) {\r\n            this.oriWidth += key.xadvance * this.scale;\r\n          } else {\r\n            this.oriWidth += key.width * this.scale;\r\n          }\r\n        }\r\n        let tmpRatio = this.oriWidth / this.fixedWidth;\r\n        lineH = this.lineHeight * this.scale * si;\r\n        let accumulate = 0;\r\n        let tmpChar = \"\";\r\n        let lineBreak = 0;\r\n        // finding position break and length of each line\r\n        // only execute if oriWidth > fixedWidth and fixedWidth > longest seq\r\n        if (tmpRatio > 1 && this.fixedWidth > maxSeq) {\r\n          for (let i = 0; i < CharSequence.length; i++) {\r\n            tmpChar += CharSequence[i];\r\n            const char = CharSequence.charCodeAt(i);\r\n            const key = this.findRegions(char);\r\n            accumulate += key.xadvance * this.scale;\r\n            // every line before last line\r\n            if (accumulate >= this.fixedWidth) {\r\n              let j = i;\r\n              while (j >= 0) {\r\n                i--;\r\n                j--;\r\n                const key2 = this.findRegions(CharSequence.charCodeAt(i));\r\n                accumulate -= key2.xadvance * this.scale;\r\n                tmpChar = tmpChar.substring(0, tmpChar.length - 1);\r\n                if (accumulate <= this.fixedWidth && key2.id === 32) {\r\n                  lineBreak = this.lineHeight * this.positionBreak.length;\r\n                  this.positionBreak.push(i); ///\r\n                  this.lastBreakIndex = i;\r\n                  const line = tmpChar.trim();\r\n                  let tmp = 0;\r\n                  let key3 = 0;\r\n\r\n                  for (let index = 0; index < line.length; index++) {\r\n                    key3 = this.findRegions(line.charCodeAt(index));\r\n                    if (index === line.length - 1) {\r\n                      tmp += key3.width * this.scale;\r\n                    } else {\r\n                      tmp += key3.xadvance * this.scale;\r\n                    }\r\n                  }\r\n                  let [px, py] = this.getPositionBasedOnMode(posX, posY, tmp);\r\n\r\n                  this.addToCache(line, px, py, lineBreak, lineH);\r\n\r\n                  accumulate = 0;\r\n                  j = -1;\r\n                  tmpChar = \"\";\r\n                }\r\n              }\r\n            }\r\n            // last line\r\n            if (i === CharSequence.length - 1 && accumulate < this.oriWidth) {\r\n              let tmpChar = \"\";\r\n              for (let j = this.lastBreakIndex; j <= i; j++) {\r\n                tmpChar += CharSequence[j];\r\n              }\r\n              const lastLine = tmpChar.trim();\r\n              let tmpXadvance = 0;\r\n              let lastKey = 0;\r\n              for (let index = 0; index < lastLine.length; index++) {\r\n                lastKey = this.findRegions(lastLine.charCodeAt(index));\r\n                if (index === lastLine.length - 1) {\r\n                  tmpXadvance += lastKey.width * this.scale;\r\n                } else {\r\n                  tmpXadvance += lastKey.xadvance * this.scale;\r\n                }\r\n              }\r\n              let [px, py] = this.getPositionBasedOnMode(\r\n                posX,\r\n                posY,\r\n                tmpXadvance\r\n              );\r\n              lineBreak = this.lineHeight * this.positionBreak.length;\r\n              this.addToCache(lastLine, px, py, lineBreak, lineH);\r\n            }\r\n          }\r\n        }\r\n        // if originWidth < fixedWidth or fixedWidth < longest sequence\r\n        if (tmpRatio <= 1 || this.fixedWidth < maxSeq) {\r\n          let [px, py] = this.getPositionBasedOnMode(posX, posY, this.oriWidth);\r\n          this.addToCache(CharSequence, px, py, 0, lineH);\r\n        }\r\n      }\r\n      if (this.type === 0) {\r\n        this.preDraw = false;\r\n      }\r\n      this.oriHeight = this.newbase;\r\n    }\r\n  };\r\n\r\n  getPositionBasedOnMode = (posX, posY, oriWidth) => {\r\n    if (this.align === 0) {\r\n      // posY -= Math.round(this.oriHeight / 2);\r\n      posX -= Math.round(oriWidth / 2);\r\n    } else if (this.align === 1) {\r\n      posX -= oriWidth;\r\n    }\r\n    return [posX, posY];\r\n  };\r\n\r\n  setAlignMode = (mode) => {\r\n    this.align = mode;\r\n  };\r\n\r\n  setType = (type) => {\r\n    this.type = type;\r\n  };\r\n\r\n  setLineHeight = (lineHeight) => {\r\n    this.lineHeight = lineHeight;\r\n  };\r\n\r\n  setFixedGlyphWidth = (fixedW) => {\r\n    this.fixedWidth = fixedW;\r\n    // this.fixedHeight = fixedH;\r\n  };\r\n\r\n  findRegions = (id) => {\r\n    for (let i = 0; i < this.regions.length; i++) {\r\n      if (this.regions[i].id === id) {\r\n        return this.regions[i];\r\n      }\r\n    }\r\n  };\r\n\r\n  draw = (batch, CharSequence = \"\", posX, posY, fontSize = this.baseLine) => {\r\n    if (this.type === 0) {\r\n      if (this.preDraw) {\r\n        this.beforeDrawing(posX, posY, fontSize, CharSequence);\r\n      }\r\n      for (let i = 0; i < this.cache.length; i++) {\r\n        let cache = this.cache[i];\r\n        cache.key.draw(batch, cache.x, cache.y, cache.width, cache.height);\r\n      }\r\n    }\r\n\r\n    if (this.type === 1) {\r\n      this.beforeDrawing(posX, posY, fontSize, CharSequence);\r\n      for (let i = 0; i < this.cache.length; i++) {\r\n        let cache = this.cache[i];\r\n        cache.key.draw(batch, cache.x, cache.y, cache.width, cache.height);\r\n      }\r\n      this.cache.length = 0;\r\n      this.positionBreak.length = 0;\r\n    }\r\n  };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}