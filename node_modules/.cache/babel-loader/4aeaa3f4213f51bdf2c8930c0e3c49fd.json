{"ast":null,"code":"var colorToFloat = require('number-util').colorToFloat;\n\nvar Class = require('klasse');\n\nmodule.exports = new Class({\n  initialize: function BaseBatchMixins(gl, shader) {\n    this._blendSrc = gl.ONE;\n    this._blendDst = gl.ONE_MINUS_SRC_ALPHA;\n    this._blendingEnabled = true;\n    this._shader = shader;\n    /**\n     * This shader will be used whenever \"null\" is passed\n     * as the batch's shader. \n     *\n     * @property {ShaderProgram} shader\n     */\n\n    this.defaultShader = this._shader;\n    /**\n     * By default, a SpriteBatch is created with its own ShaderProgram,\n     * stored in `defaultShader`. If this flag is true, on deleting the SpriteBatch, its\n     * `defaultShader` will also be deleted. If this flag is false, no shaders\n     * will be deleted on destroy.\n     *\n     * Note that if you re-assign `defaultShader`, you will need to dispose the previous\n     * default shader yoursel. \n     *\n     * @property ownsShader\n     * @type {Boolean}\n     */\n\n    this.ownsShader = true;\n    /**\n     * Whether we are currently drawing to the batch. Do not modify.\n     * \n     * @property {Boolean} drawing\n     */\n\n    this.drawing = false;\n    /**\n     * The ABGR packed color, as a single float. The default\n     * value is the color white (255, 255, 255, 255).\n     *\n     * @property {Number} color\n     * @readOnly \n     */\n\n    this.color = colorToFloat(255, 255, 255, 255);\n    /**\n     * Whether to premultiply alpha on calls to setColor. \n     * This is true by default, so that we can conveniently write:\n     *\n     *     batch.setColor(1, 0, 0, 0.25); //tints red with 25% opacity\n     *\n     * If false, you must premultiply the colors yourself to achieve\n     * the same tint, like so:\n     *\n     *     batch.setColor(0.25, 0, 0, 0.25);\n     * \n     * @property premultiplied\n     * @type {Boolean}\n     * @default  true\n     */\n\n    this.premultiplied = true;\n  },\n\n  /**\n   * A property to enable or disable blending for this sprite batch. If\n   * we are currently drawing, this will first flush the batch, and then\n   * update GL_BLEND state (enabled or disabled) with our new value.\n   * \n   * @property {Boolean} blendingEnabled\n   */\n  blendingEnabled: {\n    set: function set(val) {\n      var old = this._blendingEnabled;\n      if (this.drawing) this.flush();\n      this._blendingEnabled = val; //if we have a new value, update it.\n      //this is because blend is done in begin() / end() \n\n      if (this.drawing && old != val) {\n        var gl = this.context.gl;\n        if (val) gl.enable(gl.BLEND);else gl.disable(gl.BLEND);\n      }\n    },\n    get: function get() {\n      return this._blendingEnabled;\n    }\n  },\n\n  /**\n   * Sets the blend source parameters. \n   * If we are currently drawing, this will flush the batch.\n   *\n   * Setting either src or dst to `null` or a falsy value tells the SpriteBatch\n   * to ignore gl.blendFunc. This is useful if you wish to use your\n   * own blendFunc or blendFuncSeparate. \n   * \n   * @property {GLenum} blendDst \n   */\n  blendSrc: {\n    set: function set(val) {\n      if (this.drawing) this.flush();\n      this._blendSrc = val;\n    },\n    get: function get() {\n      return this._blendSrc;\n    }\n  },\n\n  /**\n   * Sets the blend destination parameters. \n   * If we are currently drawing, this will flush the batch.\n   *\n   * Setting either src or dst to `null` or a falsy value tells the SpriteBatch\n   * to ignore gl.blendFunc. This is useful if you wish to use your\n   * own blendFunc or blendFuncSeparate. \n   *\n   * @property {GLenum} blendSrc \n   */\n  blendDst: {\n    set: function set(val) {\n      if (this.drawing) this.flush();\n      this._blendDst = val;\n    },\n    get: function get() {\n      return this._blendDst;\n    }\n  },\n\n  /**\n   * Sets the blend source and destination parameters. This is \n   * a convenience function for the blendSrc and blendDst setters.\n   * If we are currently drawing, this will flush the batch.\n   *\n   * Setting either to `null` or a falsy value tells the SpriteBatch\n   * to ignore gl.blendFunc. This is useful if you wish to use your\n   * own blendFunc or blendFuncSeparate. \n   *\n   * @method  setBlendFunction\n   * @param {GLenum} blendSrc the source blend parameter\n   * @param {GLenum} blendDst the destination blend parameter\n   */\n  setBlendFunction: function setBlendFunction(blendSrc, blendDst) {\n    this.blendSrc = blendSrc;\n    this.blendDst = blendDst;\n  },\n\n  /**\n   * This is a setter/getter for this batch's current ShaderProgram.\n   * If this is set when the batch is drawing, the state will be flushed\n   * to the GPU and the new shader will then be bound.\n   *\n   * If `null` or a falsy value is specified, the batch's `defaultShader` will be used. \n   *\n   * Note that shaders are bound on batch.begin().\n   *\n   * @property shader\n   * @type {ShaderProgram}\n   */\n  shader: {\n    set: function set(val) {\n      var wasDrawing = this.drawing;\n\n      if (wasDrawing) {\n        this.end(); //unbinds the shader from the mesh\n      }\n\n      this._shader = val ? val : this.defaultShader;\n\n      if (wasDrawing) {\n        this.begin();\n      }\n    },\n    get: function get() {\n      return this._shader;\n    }\n  },\n\n  /**\n   * Sets the color of this sprite batcher, which is used in subsequent draw\n   * calls. This does not flush the batch.\n   *\n   * If r, g, b, are all numbers, this method assumes that RGB \n   * or RGBA float values (0.0 to 1.0) are being passed. Alpha defaults to one\n   * if undefined.\n   * \n   * If one or more of the (r, g, b) arguments are non-numbers, we only consider the first argument\n   * and assign it to all four components -- this is useful for setting transparency \n   * in a premultiplied alpha stage.\n   * \n   * If the first argument is invalid or not a number,\n   * the color defaults to (1, 1, 1, 1).\n   *\n   * @method  setColor\n   * @param {Number} r the red component, normalized\n   * @param {Number} g the green component, normalized\n   * @param {Number} b the blue component, normalized\n   * @param {Number} a the alpha component, normalized\n   */\n  setColor: function setColor(r, g, b, a) {\n    var rnum = typeof r === \"number\";\n\n    if (rnum && typeof g === \"number\" && typeof b === \"number\") {\n      //default alpha to one \n      a = typeof a === \"number\" ? a : 1.0;\n    } else {\n      r = g = b = a = rnum ? r : 1.0;\n    }\n\n    if (this.premultiplied) {\n      r *= a;\n      g *= a;\n      b *= a;\n    }\n\n    this.color = colorToFloat(~~(r * 255), ~~(g * 255), ~~(b * 255), ~~(a * 255));\n  }\n});","map":{"version":3,"sources":["E:/fcatcher-client/node_modules/kami-base-batch/mixins.js"],"names":["colorToFloat","require","Class","module","exports","initialize","BaseBatchMixins","gl","shader","_blendSrc","ONE","_blendDst","ONE_MINUS_SRC_ALPHA","_blendingEnabled","_shader","defaultShader","ownsShader","drawing","color","premultiplied","blendingEnabled","set","val","old","flush","context","enable","BLEND","disable","get","blendSrc","blendDst","setBlendFunction","wasDrawing","end","begin","setColor","r","g","b","a","rnum"],"mappings":"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","sourcesContent":["var colorToFloat = require('number-util').colorToFloat;\nvar Class = require('klasse');\n\nmodule.exports = new Class({\n\n\tinitialize: \n\tfunction BaseBatchMixins(gl, shader) {\n\t\tthis._blendSrc = gl.ONE;\n\t\tthis._blendDst = gl.ONE_MINUS_SRC_ALPHA;\n\t\tthis._blendingEnabled = true;\n\t\tthis._shader = shader;\n\n\t\t/**\n\t\t * This shader will be used whenever \"null\" is passed\n\t\t * as the batch's shader. \n\t\t *\n\t\t * @property {ShaderProgram} shader\n\t\t */\n\t\tthis.defaultShader = this._shader;\n\n\t\t/**\n\t\t * By default, a SpriteBatch is created with its own ShaderProgram,\n\t\t * stored in `defaultShader`. If this flag is true, on deleting the SpriteBatch, its\n\t\t * `defaultShader` will also be deleted. If this flag is false, no shaders\n\t\t * will be deleted on destroy.\n\t\t *\n\t\t * Note that if you re-assign `defaultShader`, you will need to dispose the previous\n\t\t * default shader yoursel. \n\t\t *\n\t\t * @property ownsShader\n\t\t * @type {Boolean}\n\t\t */\n\t\tthis.ownsShader = true;\n\n\t\t/**\n\t\t * Whether we are currently drawing to the batch. Do not modify.\n\t\t * \n\t\t * @property {Boolean} drawing\n\t\t */\n\t\tthis.drawing = false;\n\n\t\t/**\n\t\t * The ABGR packed color, as a single float. The default\n\t\t * value is the color white (255, 255, 255, 255).\n\t\t *\n\t\t * @property {Number} color\n\t\t * @readOnly \n\t\t */\n\t\tthis.color = colorToFloat(255, 255, 255, 255);\n\t\t\n\t\t/**\n\t\t * Whether to premultiply alpha on calls to setColor. \n\t\t * This is true by default, so that we can conveniently write:\n\t\t *\n\t\t *     batch.setColor(1, 0, 0, 0.25); //tints red with 25% opacity\n\t\t *\n\t\t * If false, you must premultiply the colors yourself to achieve\n\t\t * the same tint, like so:\n\t\t *\n\t\t *     batch.setColor(0.25, 0, 0, 0.25);\n\t\t * \n\t\t * @property premultiplied\n\t\t * @type {Boolean}\n\t\t * @default  true\n\t\t */\n\t\tthis.premultiplied = true;\n\t},\n\n\t/**\n\t * A property to enable or disable blending for this sprite batch. If\n\t * we are currently drawing, this will first flush the batch, and then\n\t * update GL_BLEND state (enabled or disabled) with our new value.\n\t * \n\t * @property {Boolean} blendingEnabled\n\t */\n\tblendingEnabled: {\n\t\tset: function(val) {\n\t\t\tvar old = this._blendingEnabled;\n\t\t\tif (this.drawing)\n\t\t\t\tthis.flush();\n\n\t\t\tthis._blendingEnabled = val;\n\n\t\t\t//if we have a new value, update it.\n\t\t\t//this is because blend is done in begin() / end() \n\t\t\tif (this.drawing && old != val) {\n\t\t\t\tvar gl = this.context.gl;\n\t\t\t\tif (val)\n\t\t\t\t\tgl.enable(gl.BLEND);\n\t\t\t\telse\n\t\t\t\t\tgl.disable(gl.BLEND);\n\t\t\t}\n\n\t\t},\n\n\t\tget: function() {\n\t\t\treturn this._blendingEnabled;\n\t\t}\n\t},\n\n\t/**\n\t * Sets the blend source parameters. \n\t * If we are currently drawing, this will flush the batch.\n\t *\n\t * Setting either src or dst to `null` or a falsy value tells the SpriteBatch\n\t * to ignore gl.blendFunc. This is useful if you wish to use your\n\t * own blendFunc or blendFuncSeparate. \n\t * \n\t * @property {GLenum} blendDst \n\t */\n\tblendSrc: {\n\t\tset: function(val) {\n\t\t\tif (this.drawing)\n\t\t\t\tthis.flush();\n\t\t\tthis._blendSrc = val;\n\t\t},\n\n\t\tget: function() {\n\t\t\treturn this._blendSrc;\n\t\t}\n\t},\n\n\t/**\n\t * Sets the blend destination parameters. \n\t * If we are currently drawing, this will flush the batch.\n\t *\n\t * Setting either src or dst to `null` or a falsy value tells the SpriteBatch\n\t * to ignore gl.blendFunc. This is useful if you wish to use your\n\t * own blendFunc or blendFuncSeparate. \n\t *\n\t * @property {GLenum} blendSrc \n\t */\n\tblendDst: {\n\t\tset: function(val) {\n\t\t\tif (this.drawing)\n\t\t\t\tthis.flush();\n\t\t\tthis._blendDst = val;\n\t\t},\n\n\t\tget: function() {\n\t\t\treturn this._blendDst;\n\t\t}\n\t},\n\n\t/**\n\t * Sets the blend source and destination parameters. This is \n\t * a convenience function for the blendSrc and blendDst setters.\n\t * If we are currently drawing, this will flush the batch.\n\t *\n\t * Setting either to `null` or a falsy value tells the SpriteBatch\n\t * to ignore gl.blendFunc. This is useful if you wish to use your\n\t * own blendFunc or blendFuncSeparate. \n\t *\n\t * @method  setBlendFunction\n\t * @param {GLenum} blendSrc the source blend parameter\n\t * @param {GLenum} blendDst the destination blend parameter\n\t */\n\tsetBlendFunction: function(blendSrc, blendDst) {\n\t\tthis.blendSrc = blendSrc;\n\t\tthis.blendDst = blendDst;\n\t},\n\n\t/**\n\t * This is a setter/getter for this batch's current ShaderProgram.\n\t * If this is set when the batch is drawing, the state will be flushed\n\t * to the GPU and the new shader will then be bound.\n\t *\n\t * If `null` or a falsy value is specified, the batch's `defaultShader` will be used. \n\t *\n\t * Note that shaders are bound on batch.begin().\n\t *\n\t * @property shader\n\t * @type {ShaderProgram}\n\t */\n\tshader: {\n\t\tset: function(val) {\n\t\t\tvar wasDrawing = this.drawing;\n\n\t\t\tif (wasDrawing) {\n\t\t\t\tthis.end(); //unbinds the shader from the mesh\n\t\t\t}\n\n\t\t\tthis._shader = val ? val : this.defaultShader;\n\n\t\t\tif (wasDrawing) {\n\t\t\t\tthis.begin();\n\t\t\t}\n\t\t},\n\n\t\tget: function() {\n\t\t\treturn this._shader;\n\t\t}\n\t},\n\n\t/**\n\t * Sets the color of this sprite batcher, which is used in subsequent draw\n\t * calls. This does not flush the batch.\n\t *\n\t * If r, g, b, are all numbers, this method assumes that RGB \n\t * or RGBA float values (0.0 to 1.0) are being passed. Alpha defaults to one\n\t * if undefined.\n\t * \n\t * If one or more of the (r, g, b) arguments are non-numbers, we only consider the first argument\n\t * and assign it to all four components -- this is useful for setting transparency \n\t * in a premultiplied alpha stage.\n\t * \n\t * If the first argument is invalid or not a number,\n\t * the color defaults to (1, 1, 1, 1).\n\t *\n\t * @method  setColor\n\t * @param {Number} r the red component, normalized\n\t * @param {Number} g the green component, normalized\n\t * @param {Number} b the blue component, normalized\n\t * @param {Number} a the alpha component, normalized\n\t */\n\tsetColor: function(r, g, b, a) {\n\t\tvar rnum = typeof r === \"number\";\n\t\tif (rnum\n\t\t\t\t&& typeof g === \"number\"\n\t\t\t\t&& typeof b === \"number\") {\n\t\t\t//default alpha to one \n\t\t\ta = typeof a === \"number\" ? a : 1.0;\n\t\t} else {\n\t\t\tr = g = b = a = rnum ? r : 1.0;\n\t\t}\n\t\t\n\t\tif (this.premultiplied) {\n\t\t\tr *= a;\n\t\t\tg *= a;\n\t\t\tb *= a;\n\t\t}\n\t\t\n\t\tthis.color = colorToFloat(\n\t\t\t~~(r * 255),\n\t\t\t~~(g * 255),\n\t\t\t~~(b * 255),\n\t\t\t~~(a * 255)\n\t\t);\n\t},\n});"]},"metadata":{},"sourceType":"script"}