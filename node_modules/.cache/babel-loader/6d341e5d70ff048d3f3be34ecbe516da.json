{"ast":null,"code":"import _regeneratorRuntime from \"E:\\\\fcatcher-client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/regenerator\";\nimport _slicedToArray from \"E:\\\\fcatcher-client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _asyncToGenerator from \"E:\\\\fcatcher-client\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/asyncToGenerator\";\nimport loadTexture from './loadTexture';\nimport TextureRegion from './TextureRegion';\n\nfunction concatAndResolveUrl(url, concat) {\n  var url1 = url.split('/');\n  var url2 = concat.split('/');\n  var url3 = [];\n\n  for (var i = 0, l = url1.length; i < l; i++) {\n    if (url1[i] === '..') {\n      url3.pop();\n    } else if (url1[i] === '.') {\n      continue;\n    } else {\n      url3.push(url1[i]);\n    }\n  }\n\n  for (var _i = 0, _l = url2.length; _i < _l; _i++) {\n    if (url2[_i] === '..') {\n      url3.pop();\n    } else if (url2[_i] === '.') {\n      continue;\n    } else {\n      url3.push(url2[_i]);\n    }\n  }\n\n  return url3.join('/');\n}\n\nvar TextureWrap = {\n  ClampToEdge: 0,\n  Repeat: 1\n};\nexport default /*#__PURE__*/(function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(gl, packFileUrl, textureOptions) {\n    var packFileContent, pages, regionsData, pageImage, lines, i, tuple, line, file, width, height, format, _tuple, _tuple2, min, max, direction, repeatX, repeatY, mipMaps, name, rotate, left, top, _width, _height, region, _i2, _pages, page, regions, _i3, _regionsData, regionData, x, y, _width2, _height2, _regionData$page, texture, invTexWidth, invTexHeight;\n\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetch(packFileUrl).then(function (res) {\n              return res.text();\n            });\n\n          case 2:\n            packFileContent = _context.sent;\n            pages = [];\n            regionsData = [];\n            lines = packFileContent.split('\\n').map(function (s) {\n              return s.trim();\n            });\n            i = 0;\n\n          case 7:\n            if (!true) {\n              _context.next = 15;\n              break;\n            }\n\n            line = lines[i];\n\n            if (!(line === undefined)) {\n              _context.next = 11;\n              break;\n            }\n\n            return _context.abrupt(\"break\", 15);\n\n          case 11:\n            if (line.trim().length === 0) {\n              pageImage = null;\n            } else if (pageImage === null) {\n              file = concatAndResolveUrl(packFileUrl, \"../\".concat(line));\n              i++;\n              line = lines[i];\n              tuple = line.split(':')[1].split(',').map(function (s) {\n                return s.trim();\n              });\n              width = parseInt(tuple[0], 10);\n              height = parseInt(tuple[1], 10);\n              i++;\n              line = lines[i];\n              tuple = line.split(':')[1].split(',').map(function (s) {\n                return s.trim();\n              });\n              format = tuple[0];\n              i++;\n              line = lines[i];\n              tuple = line.split(':')[1].split(',').map(function (s) {\n                return s.trim();\n              });\n              _tuple = tuple, _tuple2 = _slicedToArray(_tuple, 2), min = _tuple2[0], max = _tuple2[1];\n              i++;\n              line = lines[i];\n              tuple = line.split(':')[1].split(',').map(function (s) {\n                return s.trim();\n              });\n              direction = tuple[0];\n              repeatX = TextureWrap.ClampToEdge;\n              repeatY = TextureWrap.ClampToEdge;\n\n              if (direction === 'x') {\n                repeatX = TextureWrap.Repeat;\n              } else if (direction === 'y') {\n                repeatY = TextureWrap.Repeat;\n              } else if (direction === 'xy') {\n                repeatX = TextureWrap.Repeat;\n                repeatY = TextureWrap.Repeat;\n              }\n\n              mipMaps = min !== 'Nearest' && min !== 'Linear';\n              pageImage = {\n                file: file,\n                width: width,\n                height: height,\n                format: format,\n                mipMaps: mipMaps,\n                min: min,\n                max: max,\n                direction: direction,\n                repeatX: repeatX,\n                repeatY: repeatY\n              };\n              pages.push(pageImage);\n            } else {\n              name = line;\n              i++;\n              line = lines[i];\n              tuple = line.split(':')[1].split(',').map(function (s) {\n                return s.trim();\n              });\n              rotate = tuple[0] === 'true';\n              i++;\n              line = lines[i];\n              tuple = line.split(':')[1].split(',').map(function (s) {\n                return s.trim();\n              });\n              left = parseInt(tuple[0], 10);\n              top = parseInt(tuple[1], 10);\n              i++;\n              line = lines[i];\n              tuple = line.split(':')[1].split(',').map(function (s) {\n                return s.trim();\n              });\n              _width = parseInt(tuple[0], 10);\n              _height = parseInt(tuple[1], 10);\n              region = {\n                name: name,\n                rotate: rotate,\n                left: left,\n                top: top,\n                width: _width,\n                height: _height,\n                page: pageImage\n              };\n              i++;\n              line = lines[i];\n              tuple = line.split(':')[1].split(',').map(function (s) {\n                return s.trim();\n              });\n\n              if (tuple.length === 4) {\n                region.splits = tuple.map(function (i) {\n                  return parseInt(i, 10);\n                });\n                i++;\n                line = lines[i];\n                tuple = line.split(':')[1].split(',').map(function (s) {\n                  return s.trim();\n                });\n\n                if (tuple.length === 4) {\n                  region.pads = tuple.map(function (i) {\n                    return parseInt(i, 10);\n                  });\n                  i++;\n                  line = lines[i];\n                  tuple = line.split(':')[1].split(',').map(function (s) {\n                    return s.trim();\n                  });\n                }\n              }\n\n              region.originalWidth = parseInt(tuple[0], 10);\n              region.originalHeight = parseInt(tuple[1], 10);\n              i++;\n              line = lines[i];\n              tuple = line.split(':')[1].split(',').map(function (s) {\n                return s.trim();\n              });\n              region.offsetX = parseInt(tuple[0], 10);\n              region.offsetY = parseInt(tuple[1], 10);\n              i++;\n              line = lines[i];\n              tuple = line.split(':')[1].split(',').map(function (s) {\n                return s.trim();\n              });\n              region.index = parseInt(tuple[0], 10);\n              regionsData.push(region);\n            }\n\n            i++;\n            _context.next = 7;\n            break;\n\n          case 15:\n            _i2 = 0, _pages = pages;\n\n          case 16:\n            if (!(_i2 < _pages.length)) {\n              _context.next = 26;\n              break;\n            }\n\n            page = _pages[_i2];\n            _context.next = 20;\n            return loadTexture(gl, page.file, textureOptions);\n\n          case 20:\n            page.texture = _context.sent;\n            page.invTexWidth = 1 / page.texture.width;\n            page.invTexHeight = 1 / page.texture.height;\n\n          case 23:\n            _i2++;\n            _context.next = 16;\n            break;\n\n          case 26:\n            regions = [];\n\n            for (_i3 = 0, _regionsData = regionsData; _i3 < _regionsData.length; _i3++) {\n              regionData = _regionsData[_i3];\n              x = regionData.left, y = regionData.top;\n              _width2 = regionData.rotate ? regionData.height : regionData.width;\n              _height2 = regionData.rotate ? regionData.width : regionData.height;\n              _regionData$page = regionData.page, texture = _regionData$page.texture, invTexWidth = _regionData$page.invTexWidth, invTexHeight = _regionData$page.invTexHeight;\n              regions.push(new TextureRegion(texture, x, y, _width2, _height2, regionData, invTexWidth, invTexHeight, regionData.rotate));\n            }\n\n            return _context.abrupt(\"return\", {\n              getPages: function getPages() {\n                return pages;\n              },\n              getRegions: function getRegions() {\n                return regions;\n              },\n              findRegion: function findRegion(name, index) {\n                for (var _i4 = 0; _i4 < regions.length; _i4++) {\n                  var _region = regions[_i4];\n                  if (_region.name !== name) continue;\n                  if (index !== undefined && _region.index !== index) continue;\n                  return _region;\n                }\n\n                return null;\n              },\n              findRegions: function findRegions(name) {\n                return regions.filter(function (region) {\n                  return region.name === name;\n                }).sort(function (a, b) {\n                  return a.index - b.index;\n                });\n              }\n            });\n\n          case 29:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function (_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n})();","map":{"version":3,"sources":["E:/fcatcher-client/node_modules/gdxjs/lib/loadAtlas.js"],"names":["loadTexture","TextureRegion","concatAndResolveUrl","url","concat","url1","split","url2","url3","i","l","length","pop","push","join","TextureWrap","ClampToEdge","Repeat","gl","packFileUrl","textureOptions","fetch","then","res","text","packFileContent","pages","regionsData","lines","map","s","trim","line","undefined","pageImage","file","tuple","width","parseInt","height","format","min","max","direction","repeatX","repeatY","mipMaps","name","rotate","left","top","region","page","splits","pads","originalWidth","originalHeight","offsetX","offsetY","index","texture","invTexWidth","invTexHeight","regions","regionData","x","y","getPages","getRegions","findRegion","findRegions","filter","sort","a","b"],"mappings":"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","sourcesContent":["import loadTexture from './loadTexture';\nimport TextureRegion from './TextureRegion';\n\nfunction concatAndResolveUrl(url, concat) {\n  let url1 = url.split('/');\n  let url2 = concat.split('/');\n  let url3 = [];\n\n  for (let i = 0, l = url1.length; i < l; i++) {\n    if (url1[i] === '..') {\n      url3.pop();\n    } else if (url1[i] === '.') {\n      continue;\n    } else {\n      url3.push(url1[i]);\n    }\n  }\n\n  for (let i = 0, l = url2.length; i < l; i++) {\n    if (url2[i] === '..') {\n      url3.pop();\n    } else if (url2[i] === '.') {\n      continue;\n    } else {\n      url3.push(url2[i]);\n    }\n  }\n\n  return url3.join('/');\n}\n\nconst TextureWrap = {\n  ClampToEdge: 0,\n  Repeat: 1\n};\nexport default (async (gl, packFileUrl, textureOptions) => {\n  const packFileContent = await fetch(packFileUrl).then(res => res.text());\n  const pages = [];\n  const regionsData = [];\n  let pageImage;\n  const lines = packFileContent.split('\\n').map(s => s.trim());\n  let i = 0;\n  let tuple;\n\n  while (true) {\n    let line = lines[i];\n\n    if (line === undefined) {\n      break;\n    }\n\n    if (line.trim().length === 0) {\n      pageImage = null;\n    } else if (pageImage === null) {\n      const file = concatAndResolveUrl(packFileUrl, `../${line}`);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const width = parseInt(tuple[0], 10);\n      const height = parseInt(tuple[1], 10);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const format = tuple[0];\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const [min, max] = tuple;\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const direction = tuple[0];\n      let repeatX = TextureWrap.ClampToEdge;\n      let repeatY = TextureWrap.ClampToEdge;\n\n      if (direction === 'x') {\n        repeatX = TextureWrap.Repeat;\n      } else if (direction === 'y') {\n        repeatY = TextureWrap.Repeat;\n      } else if (direction === 'xy') {\n        repeatX = TextureWrap.Repeat;\n        repeatY = TextureWrap.Repeat;\n      }\n\n      const mipMaps = min !== 'Nearest' && min !== 'Linear';\n      pageImage = {\n        file,\n        width,\n        height,\n        format,\n        mipMaps,\n        min,\n        max,\n        direction,\n        repeatX,\n        repeatY\n      };\n      pages.push(pageImage);\n    } else {\n      const name = line;\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const rotate = tuple[0] === 'true';\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const left = parseInt(tuple[0], 10);\n      const top = parseInt(tuple[1], 10);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      const width = parseInt(tuple[0], 10);\n      const height = parseInt(tuple[1], 10);\n      const region = {\n        name,\n        rotate,\n        left,\n        top,\n        width,\n        height,\n        page: pageImage\n      };\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n\n      if (tuple.length === 4) {\n        region.splits = tuple.map(i => parseInt(i, 10));\n        i++;\n        line = lines[i];\n        tuple = line.split(':')[1].split(',').map(s => s.trim());\n\n        if (tuple.length === 4) {\n          region.pads = tuple.map(i => parseInt(i, 10));\n          i++;\n          line = lines[i];\n          tuple = line.split(':')[1].split(',').map(s => s.trim());\n        }\n      }\n\n      region.originalWidth = parseInt(tuple[0], 10);\n      region.originalHeight = parseInt(tuple[1], 10);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      region.offsetX = parseInt(tuple[0], 10);\n      region.offsetY = parseInt(tuple[1], 10);\n      i++;\n      line = lines[i];\n      tuple = line.split(':')[1].split(',').map(s => s.trim());\n      region.index = parseInt(tuple[0], 10);\n      regionsData.push(region);\n    }\n\n    i++;\n  }\n\n  for (let page of pages) {\n    page.texture = await loadTexture(gl, page.file, textureOptions);\n    page.invTexWidth = 1 / page.texture.width;\n    page.invTexHeight = 1 / page.texture.height;\n  }\n\n  const regions = [];\n\n  for (let regionData of regionsData) {\n    const {\n      left: x,\n      top: y\n    } = regionData;\n    const width = regionData.rotate ? regionData.height : regionData.width;\n    const height = regionData.rotate ? regionData.width : regionData.height;\n    const {\n      texture,\n      invTexWidth,\n      invTexHeight\n    } = regionData.page;\n    regions.push(new TextureRegion(texture, x, y, width, height, regionData, invTexWidth, invTexHeight, regionData.rotate));\n  }\n\n  return {\n    getPages() {\n      return pages;\n    },\n\n    getRegions() {\n      return regions;\n    },\n\n    findRegion(name, index) {\n      for (let i = 0; i < regions.length; i++) {\n        let region = regions[i];\n        if (region.name !== name) continue;\n        if (index !== undefined && region.index !== index) continue;\n        return region;\n      }\n\n      return null;\n    },\n\n    findRegions(name) {\n      return regions.filter(region => region.name === name).sort((a, b) => a.index - b.index);\n    }\n\n  };\n});"]},"metadata":{},"sourceType":"module"}