{"ast":null,"code":"/**\n * Texture utils for kami.\n *\n * @module kami-texture\n */\nvar Class = require(\"klasse\");\n\nvar nextPowerOfTwo = require(\"number-util\").nextPowerOfTwo;\n\nvar isPowerOfTwo = require(\"number-util\").isPowerOfTwo;\n\nvar BaseObject = require(\"kami-util\").BaseObject;\n\nvar Texture = new Class({\n  /**\n   * Creates a new texture with the optional width, height, and data.\n   *\n   * If the constructor is passed no parameters other than the context, then\n   * it will not be initialized and will be non-renderable. You will need to manually\n   * uploadData or uploadImage yourself.\n   *\n   * If the options passed includes 'src', it assumes an image is to be loaded,\n   * and will use the width/height from that resulting image. Otherwise, it\n   * will look for 'data', which may be a typed array or any valid \"image\" object.\n   * A typed array will need its width/height passed explicitly.\n   *\n   * If the context is a kami-context, we will try to manage the Texture object by\n   * keeping the arguments in memory for future use.\n   *\n   * Most users will want to use the AssetManager to create and manage their textures\n   * with asynchronous loading and context loss.\n   *\n   * @class  Texture\n   * @constructor\n   * @param  {WebGLRenderingContext|kami-context} context the WebGL context\n   * @param  {Object} options the options to create this texture\n   *   @param {String} options.src the path to the image file, if ommitted we assume data will be given\n   *   @param {Function} options.onLoad called when the image is loaded (if src is provided)\n   *   @param {Function} options.onError called when there was an error loading the image (if src is provided)\n   *   @param {String} options.crossOrigin the image cross-origin parameter (if src is provided)\n   *   @param {ArrayBuffer} options.data some typed array with texture data, ignored if 'src' is specified\n   *   @param {GLenum} options.format the texture format, default Texture.Format.RGBA (for when data is specified)\n   *   @param {GLenum} options.type the data type, default Texture.DataType.UNSIGNED_BYTE (for when data is specified)\n   *   @param {Number} options.width the width of the texture (if we are not specifying an image URL)\n   *   @param {Number} options.height the height of the texture (if we are not specifying an image URL)\n   *   @param {Boolean} options.genMipmaps whether to generate mipmaps after upload\n   */\n  initialize: function Texture(context, options) {\n    if (!(this instanceof Texture)) return new Texture(context, options); //sets up base Kami object..\n\n    BaseObject.call(this, context);\n    /**\n     * When a texture is created, we keep track of the arguments provided to\n     * its constructor. On context loss and restore, these arguments are re-supplied\n     * to the Texture, so as to re-create it in its correct form.\n     *\n     * This is mainly useful if you are procedurally creating textures and passing\n     * their data directly (e.g. for generic lookup tables in a shader). For image\n     * or media based textures, it would be better to use an AssetManager to manage\n     * the asynchronous texture upload.\n     *\n     * Upon destroying a texture, a reference to this is also lost.\n     *\n     * @property managedArgs\n     * @type {Object} the options given to the Texture constructor, or undefined\n     */\n\n    this.managedArgs = options;\n    /**\n     * The WebGLTexture which backs this Texture object. This\n     * can be used for low-level GL calls.\n     *\n     * @type {WebGLTexture}\n     */\n\n    this.id = null; //initialized in create()\n\n    /**\n     * The target for this texture unit, i.e. TEXTURE_2D. Subclasses\n     * should override the create() method to change this, for correct\n     * usage with context restore.\n     *\n     * @property target\n     * @type {GLenum}\n     * @default  gl.TEXTURE_2D\n     */\n\n    this.target = this.context.gl.TEXTURE_2D;\n    /**\n     * The width of this texture, in pixels.\n     *\n     * @property width\n     * @readOnly\n     * @type {Number} the width\n     */\n\n    this.width = 0; //initialized on texture upload\n\n    /**\n     * The height of this texture, in pixels.\n     *\n     * @property height\n     * @readOnly\n     * @type {Number} the height\n     */\n\n    this.height = 0; //initialized on texture upload\n\n    this.__shape = [0, 0];\n    /**\n     * The S wrap parameter.\n     * @property {GLenum} wrapS\n     */\n\n    this.wrapS = Texture.DEFAULT_WRAP;\n    /**\n     * The T wrap parameter.\n     * @property {GLenum} wrapT\n     */\n\n    this.wrapT = Texture.DEFAULT_WRAP;\n    /**\n     * The minifcation filter.\n     * @property {GLenum} minFilter\n     */\n\n    this.minFilter = Texture.DEFAULT_FILTER;\n    /**\n     * The magnification filter.\n     * @property {GLenum} magFilter\n     */\n\n    this.magFilter = Texture.DEFAULT_FILTER; //manage if we're dealing with a kami-context\n\n    this.context.addManagedObject(this);\n    this.create();\n  },\n\n  /**\n   * This can be called after creating a Texture to load an Image object asynchronously,\n   * or upload image data directly. It takes the same options as the constructor.\n   *\n   * Users will generally not need to call this directly.\n   *\n   * @protected\n   * @method  setup\n   */\n  setup: function setup(options) {\n    var gl = this.gl; //If no options is provided... this method does nothing.\n\n    if (!options) return; // width, height, format, dataType, data, genMipmaps\n    //If 'src' is provided, try to load the image from a path...\n\n    if (options.src && typeof options.src === \"string\") {\n      var img = new Image();\n      var path = options.src;\n      var crossOrigin = options.crossOrigin;\n      var successCB = typeof options.onLoad === \"function\" ? options.onLoad : null;\n      var failCB = typeof options.onError === \"function\" ? options.onError : null;\n      var genMipmaps = options.genMipmaps;\n      var self = this; //If you try to render a texture that is not yet \"renderable\" (i.e. the\n      //async load hasn't completed yet, which is always the case in Chrome since requestAnimationFrame\n      //fires before img.onload), WebGL will throw us errors. So instead we will just upload some\n      //dummy data until the texture load is complete. Users can disable this with the global flag.\n\n      if (Texture.USE_DUMMY_1x1_DATA) {\n        self.uploadData(1, 1);\n        this.width = this.height = 0;\n      }\n\n      img.crossOrigin = crossOrigin;\n\n      img.onload = function (ev) {\n        self.uploadImage(img, undefined, undefined, genMipmaps);\n        if (typeof successCB === \"function\") successCB.call(self, ev, self);\n      };\n\n      img.onerror = function (ev) {\n        if (genMipmaps) //we still need to gen mipmaps on the 1x1 dummy\n          gl.generateMipmap(gl.TEXTURE_2D);\n        if (typeof failCB === \"function\") failCB.call(self, ev, self);\n      };\n\n      img.onabort = function (ev) {\n        if (genMipmaps) gl.generateMipmap(gl.TEXTURE_2D);\n        if (typeof failCB === \"function\") failCB.call(self, ev, self);\n      };\n\n      img.src = path;\n    } //otherwise see if we have an 'image' specified\n    else if (options.image) {\n        this.uploadImage(options.image, options.format, options.dataType, options.genMipmaps);\n      } //otherwise assume our regular list of width/height arguments are passed\n      else {\n          this.uploadData(options.width, options.height, options.format, options.dataType, options.data, options.genMipmaps);\n        }\n  },\n\n  /**\n   * Called in the Texture constructor, and after the GL context has been re-initialized.\n   * Subclasses can override this to provide a custom data upload, e.g. cubemaps or compressed\n   * textures.\n   *\n   * @method  create\n   */\n  create: function create() {\n    this.gl = this.context.gl;\n    var gl = this.gl;\n    this.id = gl.createTexture(); //texture ID is recreated\n\n    this.width = this.height = 0; //size is reset to zero until loaded\n\n    this.target = gl.TEXTURE_2D; //the provider can change this if necessary (e.g. cube maps)\n\n    this.bind(); //TODO: clean these up a little.\n\n    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Texture.UNPACK_PREMULTIPLY_ALPHA);\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, Texture.UNPACK_ALIGNMENT);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, Texture.UNPACK_FLIP_Y);\n    var colorspace = Texture.UNPACK_COLORSPACE_CONVERSION || gl.BROWSER_DEFAULT_WEBGL;\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, colorspace); //setup wrap modes without binding redundantly\n\n    this.setWrap(this.wrapS, this.wrapT, false);\n    this.setFilter(this.minFilter, this.magFilter, false);\n\n    if (this.managedArgs) {\n      this.setup(this.managedArgs);\n    }\n  },\n\n  /**\n   * Destroys this texture by deleting the GL resource,\n   * removing it from the WebGLContext management stack,\n   * setting its size to zero, and id and managed arguments to null.\n   *\n   * Trying to use this texture after may lead to undefined behaviour.\n   *\n   * @method  destroy\n   */\n  destroy: function destroy() {\n    if (this.id && this.gl) this.gl.deleteTexture(this.id);\n    if (this.context) this.context.removeManagedObject(this);\n    this.width = this.height = 0;\n    this.id = null;\n    this.managedArgs = null;\n    this.context = null;\n    this.gl = null;\n  },\n\n  /**\n   * Sets the wrap mode for this texture; if the second argument\n   * is undefined or falsy, then both S and T wrap will use the first\n   * argument.\n   *\n   * You can use Texture.Wrap constants for convenience, to avoid needing\n   * a GL reference.\n   *\n   * @method  setWrap\n   * @param {GLenum} s the S wrap mode\n   * @param {GLenum} t the T wrap mode\n   * @param {Boolean} ignoreBind (optional) if true, the bind will be ignored.\n   */\n  setWrap: function setWrap(s, t, ignoreBind) {\n    //TODO: support R wrap mode\n    if (s && t) {\n      this.wrapS = s;\n      this.wrapT = t;\n    } else this.wrapS = this.wrapT = s; //enforce POT rules..\n\n\n    this._checkPOT();\n\n    if (!ignoreBind) this.bind();\n    var gl = this.gl;\n    gl.texParameteri(this.target, gl.TEXTURE_WRAP_S, this.wrapS);\n    gl.texParameteri(this.target, gl.TEXTURE_WRAP_T, this.wrapT);\n  },\n\n  /**\n   * Sets the min and mag filter for this texture;\n   * if mag is undefined or falsy, then both min and mag will use the\n   * filter specified for min.\n   *\n   * You can use Texture.Filter constants for convenience, to avoid needing\n   * a GL reference.\n   *\n   * @method  setFilter\n   * @param {GLenum} min the minification filter\n   * @param {GLenum} mag the magnification filter\n   * @param {Boolean} ignoreBind if true, the bind will be ignored.\n   */\n  setFilter: function setFilter(min, mag, ignoreBind) {\n    if (min && mag) {\n      this.minFilter = min;\n      this.magFilter = mag;\n    } else this.minFilter = this.magFilter = min; //enforce POT rules..\n\n\n    this._checkPOT();\n\n    if (!ignoreBind) this.bind();\n    var gl = this.gl;\n    gl.texParameteri(this.target, gl.TEXTURE_MIN_FILTER, this.minFilter);\n    gl.texParameteri(this.target, gl.TEXTURE_MAG_FILTER, this.magFilter);\n  },\n\n  /**\n   * A low-level method to upload the specified ArrayBufferView\n   * to this texture. This will cause the width and height of this\n   * texture to change.\n   *\n   * @method  uploadData\n   * @param  {Number} width          the new width of this texture,\n   *                                 defaults to the last used width (or zero)\n   * @param  {Number} height         the new height of this texture\n   *                                 defaults to the last used height (or zero)\n   * @param  {GLenum} format         the data format, default RGBA\n   * @param  {GLenum} type           the data type, default UNSIGNED_BYTE (Uint8Array)\n   * @param  {ArrayBufferView} data  the raw data for this texture, or null for an empty image\n   * @param  {Boolean} genMipmaps\t   whether to generate mipmaps after uploading the data, default false\n   */\n  uploadData: function uploadData(width, height, format, type, data, genMipmaps) {\n    var gl = this.gl;\n    format = format || gl.RGBA;\n    type = type || gl.UNSIGNED_BYTE;\n    data = data || null; //make sure falsey value is null for texImage2D\n\n    this.width = width || width == 0 ? width : this.width;\n    this.height = height || height == 0 ? height : this.height;\n\n    this._checkPOT();\n\n    this.bind();\n    gl.texImage2D(this.target, 0, format, this.width, this.height, 0, format, type, data);\n    if (genMipmaps) gl.generateMipmap(this.target);\n  },\n\n  /**\n   * Uploads ImageData, HTMLImageElement, HTMLCanvasElement or\n   * HTMLVideoElement.\n   *\n   * @method  uploadImage\n   * @param  {Object} domObject the DOM image container\n   * @param  {GLenum} format the format, default gl.RGBA\n   * @param  {GLenum} type the data type, default gl.UNSIGNED_BYTE\n   * @param  {Boolean} genMipmaps whether to generate mipmaps after uploading the data, default false\n   */\n  uploadImage: function uploadImage(domObject, format, type, genMipmaps) {\n    var gl = this.gl;\n    format = format || gl.RGBA;\n    type = type || gl.UNSIGNED_BYTE;\n    this.width = domObject.width;\n    this.height = domObject.height;\n\n    this._checkPOT();\n\n    this.bind();\n    gl.texImage2D(this.target, 0, format, format, type, domObject);\n    if (genMipmaps) gl.generateMipmap(this.target);\n  },\n  uploadSubImage: function uploadSubImage() {},\n\n  /**\n   * If FORCE_POT is false, we verify this texture to see if it is valid,\n   * as per non-power-of-two rules. If it is non-power-of-two, it must have\n   * a wrap mode of CLAMP_TO_EDGE, and the minification filter must be LINEAR\n   * or NEAREST. If we don't satisfy these needs, an error is thrown.\n   *\n   * @method  _checkPOT\n   * @private\n   * @return {[type]} [description]\n   */\n  _checkPOT: function _checkPOT() {\n    if (!Texture.FORCE_POT) {\n      //If minFilter is anything but LINEAR or NEAREST\n      //or if wrapS or wrapT are not CLAMP_TO_EDGE...\n      var wrongFilter = this.minFilter !== Texture.Filter.LINEAR && this.minFilter !== Texture.Filter.NEAREST;\n      var wrongWrap = this.wrapS !== Texture.Wrap.CLAMP_TO_EDGE || this.wrapT !== Texture.Wrap.CLAMP_TO_EDGE;\n\n      if (wrongFilter || wrongWrap) {\n        if (!isPowerOfTwo(this.width) || !isPowerOfTwo(this.height)) throw new Error(wrongFilter ? \"Non-power-of-two textures cannot use mipmapping as filter\" : \"Non-power-of-two textures must use CLAMP_TO_EDGE as wrap\");\n      }\n    }\n  },\n\n  /**\n   * Binds the texture. If unit is specified,\n   * it will bind the texture at the given slot\n   * (TEXTURE0, TEXTURE1, etc). If unit is not specified,\n   * it will simply bind the texture at whichever slot\n   * is currently active.\n   *\n   * @method  bind\n   * @param  {Number} unit the texture unit index, starting at 0\n   */\n  bind: function bind(unit) {\n    var gl = this.gl;\n    if (unit || unit === 0) gl.activeTexture(gl.TEXTURE0 + unit);\n    gl.bindTexture(this.target, this.id);\n  },\n  toString: function toString() {\n    return this.id + \":\" + this.width + \"x\" + this.height + \"\";\n  },\n  shape: {\n    get: function get() {\n      this.__shape[0] = this.width;\n      this.__shape[1] = this.height;\n      return this.__shape;\n    },\n    set: function set(shape) {\n      throw new Error(\"changing shape not supported\");\n    }\n  }\n});\n/**\n * A set of Filter constants that match their GL counterparts.\n * This is for convenience, to avoid the need for a GL rendering context.\n *\n * @example\n * ```\n *     Texture.Filter.NEAREST\n *     Texture.Filter.NEAREST_MIPMAP_LINEAR\n *     Texture.Filter.NEAREST_MIPMAP_NEAREST\n *     Texture.Filter.LINEAR\n *     Texture.Filter.LINEAR_MIPMAP_LINEAR\n *     Texture.Filter.LINEAR_MIPMAP_NEAREST\n * ```\n * @attribute Filter\n * @static\n * @type {Object}\n */\n\nTexture.Filter = {\n  NEAREST: 9728,\n  NEAREST_MIPMAP_LINEAR: 9986,\n  NEAREST_MIPMAP_NEAREST: 9984,\n  LINEAR: 9729,\n  LINEAR_MIPMAP_LINEAR: 9987,\n  LINEAR_MIPMAP_NEAREST: 9985\n};\n/**\n * A set of Wrap constants that match their GL counterparts.\n * This is for convenience, to avoid the need for a GL rendering context.\n *\n * @example\n * ```\n *     Texture.Wrap.CLAMP_TO_EDGE\n *     Texture.Wrap.MIRRORED_REPEAT\n *     Texture.Wrap.REPEAT\n * ```\n * @attribute Wrap\n * @static\n * @type {Object}\n */\n\nTexture.Wrap = {\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\n/**\n * A set of Format constants that match their GL counterparts.\n * This is for convenience, to avoid the need for a GL rendering context.\n *\n * @example\n * ```\n *     Texture.Format.RGB\n *     Texture.Format.RGBA\n *     Texture.Format.LUMINANCE_ALPHA\n * ```\n * @attribute Format\n * @static\n * @type {Object}\n */\n\nTexture.Format = {\n  DEPTH_COMPONENT: 6402,\n  ALPHA: 6406,\n  RGBA: 6408,\n  RGB: 6407,\n  LUMINANCE: 6409,\n  LUMINANCE_ALPHA: 6410\n};\n/**\n * A set of DataType constants that match their GL counterparts.\n * This is for convenience, to avoid the need for a GL rendering context.\n *\n * @example\n * ```\n *     Texture.DataType.UNSIGNED_BYTE\n *     Texture.DataType.FLOAT\n * ```\n * @attribute DataType\n * @static\n * @type {Object}\n */\n\nTexture.DataType = {\n  BYTE: 5120,\n  SHORT: 5122,\n  INT: 5124,\n  FLOAT: 5126,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_INT: 5125,\n  UNSIGNED_SHORT: 5123,\n  UNSIGNED_SHORT_4_4_4_4: 32819,\n  UNSIGNED_SHORT_5_5_5_1: 32820,\n  UNSIGNED_SHORT_5_6_5: 33635\n};\n/**\n * The default wrap mode when creating new textures. If a custom\n * provider was specified, it may choose to override this default mode.\n *\n * @attribute {GLenum} DEFAULT_WRAP\n * @static\n * @default  Texture.Wrap.CLAMP_TO_EDGE\n */\n\nTexture.DEFAULT_WRAP = Texture.Wrap.CLAMP_TO_EDGE;\n/**\n * The default filter mode when creating new textures. If a custom\n * provider was specified, it may choose to override this default mode.\n *\n * @attribute {GLenum} DEFAULT_FILTER\n * @static\n * @default  Texture.Filter.LINEAR\n */\n\nTexture.DEFAULT_FILTER = Texture.Filter.NEAREST;\n/**\n * By default, we do some error checking when creating textures\n * to ensure that they will be \"renderable\" by WebGL. Non-power-of-two\n * textures must use CLAMP_TO_EDGE as their wrap mode, and NEAREST or LINEAR\n * as their wrap mode. Further, trying to generate mipmaps for a NPOT image\n * will lead to errors.\n *\n * However, you can disable this error checking by setting `FORCE_POT` to true.\n * This may be useful if you are running on specific hardware that supports POT\n * textures, or in some future case where NPOT textures is added as a WebGL extension.\n *\n * @attribute {Boolean} FORCE_POT\n * @static\n * @default  false\n */\n\nTexture.FORCE_POT = false; //default pixel store operations. Used in create()\n\nTexture.UNPACK_FLIP_Y = false;\nTexture.UNPACK_ALIGNMENT = 1;\nTexture.UNPACK_PREMULTIPLY_ALPHA = true;\nTexture.UNPACK_COLORSPACE_CONVERSION = undefined; //for the Image constructor we need to handle things a bit differently..\n\nTexture.USE_DUMMY_1x1_DATA = true;\n/**\n * Utility to get the number of components for the given GLenum, e.g. gl.RGBA returns 4.\n * Returns null if the specified format is not of type DEPTH_COMPONENT, ALPHA, LUMINANCE,\n * LUMINANCE_ALPHA, RGB, or RGBA.\n *\n * @method getNumComponents\n * @static\n * @param  {GLenum} format a texture format, i.e. Texture.Format.RGBA\n * @return {Number} the number of components for this format\n */\n\nTexture.getNumComponents = function (format) {\n  switch (format) {\n    case Texture.Format.DEPTH_COMPONENT:\n    case Texture.Format.ALPHA:\n    case Texture.Format.LUMINANCE:\n      return 1;\n\n    case Texture.Format.LUMINANCE_ALPHA:\n      return 2;\n\n    case Texture.Format.RGB:\n      return 3;\n\n    case Texture.Format.RGBA:\n      return 4;\n  }\n\n  return null;\n};\n\nmodule.exports = Texture;","map":{"version":3,"sources":["E:/fcatcher-client/node_modules/kami-texture2/index.js"],"names":["Class","require","nextPowerOfTwo","isPowerOfTwo","BaseObject","Texture","initialize","context","options","call","managedArgs","id","target","gl","TEXTURE_2D","width","height","__shape","wrapS","DEFAULT_WRAP","wrapT","minFilter","DEFAULT_FILTER","magFilter","addManagedObject","create","setup","src","img","Image","path","crossOrigin","successCB","onLoad","failCB","onError","genMipmaps","self","USE_DUMMY_1x1_DATA","uploadData","onload","ev","uploadImage","undefined","onerror","generateMipmap","onabort","image","format","dataType","data","createTexture","bind","pixelStorei","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_PREMULTIPLY_ALPHA","UNPACK_ALIGNMENT","UNPACK_FLIP_Y_WEBGL","UNPACK_FLIP_Y","colorspace","UNPACK_COLORSPACE_CONVERSION","BROWSER_DEFAULT_WEBGL","UNPACK_COLORSPACE_CONVERSION_WEBGL","setWrap","setFilter","destroy","deleteTexture","removeManagedObject","s","t","ignoreBind","_checkPOT","texParameteri","TEXTURE_WRAP_S","TEXTURE_WRAP_T","min","mag","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","type","RGBA","UNSIGNED_BYTE","texImage2D","domObject","uploadSubImage","FORCE_POT","wrongFilter","Filter","LINEAR","NEAREST","wrongWrap","Wrap","CLAMP_TO_EDGE","Error","unit","activeTexture","TEXTURE0","bindTexture","toString","shape","get","set","NEAREST_MIPMAP_LINEAR","NEAREST_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","MIRRORED_REPEAT","REPEAT","Format","DEPTH_COMPONENT","ALPHA","RGB","LUMINANCE","LUMINANCE_ALPHA","DataType","BYTE","SHORT","INT","FLOAT","UNSIGNED_INT","UNSIGNED_SHORT","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","UNSIGNED_SHORT_5_6_5","getNumComponents","module","exports"],"mappings":"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","sourcesContent":["/**\n * Texture utils for kami.\n *\n * @module kami-texture\n */\n\nvar Class = require(\"klasse\");\nvar nextPowerOfTwo = require(\"number-util\").nextPowerOfTwo;\nvar isPowerOfTwo = require(\"number-util\").isPowerOfTwo;\nvar BaseObject = require(\"kami-util\").BaseObject;\n\nvar Texture = new Class({\n  /**\n   * Creates a new texture with the optional width, height, and data.\n   *\n   * If the constructor is passed no parameters other than the context, then\n   * it will not be initialized and will be non-renderable. You will need to manually\n   * uploadData or uploadImage yourself.\n   *\n   * If the options passed includes 'src', it assumes an image is to be loaded,\n   * and will use the width/height from that resulting image. Otherwise, it\n   * will look for 'data', which may be a typed array or any valid \"image\" object.\n   * A typed array will need its width/height passed explicitly.\n   *\n   * If the context is a kami-context, we will try to manage the Texture object by\n   * keeping the arguments in memory for future use.\n   *\n   * Most users will want to use the AssetManager to create and manage their textures\n   * with asynchronous loading and context loss.\n   *\n   * @class  Texture\n   * @constructor\n   * @param  {WebGLRenderingContext|kami-context} context the WebGL context\n   * @param  {Object} options the options to create this texture\n   *   @param {String} options.src the path to the image file, if ommitted we assume data will be given\n   *   @param {Function} options.onLoad called when the image is loaded (if src is provided)\n   *   @param {Function} options.onError called when there was an error loading the image (if src is provided)\n   *   @param {String} options.crossOrigin the image cross-origin parameter (if src is provided)\n   *   @param {ArrayBuffer} options.data some typed array with texture data, ignored if 'src' is specified\n   *   @param {GLenum} options.format the texture format, default Texture.Format.RGBA (for when data is specified)\n   *   @param {GLenum} options.type the data type, default Texture.DataType.UNSIGNED_BYTE (for when data is specified)\n   *   @param {Number} options.width the width of the texture (if we are not specifying an image URL)\n   *   @param {Number} options.height the height of the texture (if we are not specifying an image URL)\n   *   @param {Boolean} options.genMipmaps whether to generate mipmaps after upload\n   */\n  initialize: function Texture(context, options) {\n    if (!(this instanceof Texture)) return new Texture(context, options);\n\n    //sets up base Kami object..\n    BaseObject.call(this, context);\n\n    /**\n     * When a texture is created, we keep track of the arguments provided to\n     * its constructor. On context loss and restore, these arguments are re-supplied\n     * to the Texture, so as to re-create it in its correct form.\n     *\n     * This is mainly useful if you are procedurally creating textures and passing\n     * their data directly (e.g. for generic lookup tables in a shader). For image\n     * or media based textures, it would be better to use an AssetManager to manage\n     * the asynchronous texture upload.\n     *\n     * Upon destroying a texture, a reference to this is also lost.\n     *\n     * @property managedArgs\n     * @type {Object} the options given to the Texture constructor, or undefined\n     */\n    this.managedArgs = options;\n\n    /**\n     * The WebGLTexture which backs this Texture object. This\n     * can be used for low-level GL calls.\n     *\n     * @type {WebGLTexture}\n     */\n    this.id = null; //initialized in create()\n\n    /**\n     * The target for this texture unit, i.e. TEXTURE_2D. Subclasses\n     * should override the create() method to change this, for correct\n     * usage with context restore.\n     *\n     * @property target\n     * @type {GLenum}\n     * @default  gl.TEXTURE_2D\n     */\n    this.target = this.context.gl.TEXTURE_2D;\n\n    /**\n     * The width of this texture, in pixels.\n     *\n     * @property width\n     * @readOnly\n     * @type {Number} the width\n     */\n    this.width = 0; //initialized on texture upload\n\n    /**\n     * The height of this texture, in pixels.\n     *\n     * @property height\n     * @readOnly\n     * @type {Number} the height\n     */\n    this.height = 0; //initialized on texture upload\n\n    this.__shape = [0, 0];\n\n    /**\n     * The S wrap parameter.\n     * @property {GLenum} wrapS\n     */\n    this.wrapS = Texture.DEFAULT_WRAP;\n    /**\n     * The T wrap parameter.\n     * @property {GLenum} wrapT\n     */\n    this.wrapT = Texture.DEFAULT_WRAP;\n    /**\n     * The minifcation filter.\n     * @property {GLenum} minFilter\n     */\n    this.minFilter = Texture.DEFAULT_FILTER;\n\n    /**\n     * The magnification filter.\n     * @property {GLenum} magFilter\n     */\n    this.magFilter = Texture.DEFAULT_FILTER;\n\n    //manage if we're dealing with a kami-context\n    this.context.addManagedObject(this);\n    this.create();\n  },\n\n  /**\n   * This can be called after creating a Texture to load an Image object asynchronously,\n   * or upload image data directly. It takes the same options as the constructor.\n   *\n   * Users will generally not need to call this directly.\n   *\n   * @protected\n   * @method  setup\n   */\n  setup: function(options) {\n    var gl = this.gl;\n\n    //If no options is provided... this method does nothing.\n    if (!options) return;\n\n    // width, height, format, dataType, data, genMipmaps\n\n    //If 'src' is provided, try to load the image from a path...\n    if (options.src && typeof options.src === \"string\") {\n      var img = new Image();\n      var path = options.src;\n      var crossOrigin = options.crossOrigin;\n      var successCB =\n        typeof options.onLoad === \"function\" ? options.onLoad : null;\n      var failCB =\n        typeof options.onError === \"function\" ? options.onError : null;\n      var genMipmaps = options.genMipmaps;\n\n      var self = this;\n\n      //If you try to render a texture that is not yet \"renderable\" (i.e. the\n      //async load hasn't completed yet, which is always the case in Chrome since requestAnimationFrame\n      //fires before img.onload), WebGL will throw us errors. So instead we will just upload some\n      //dummy data until the texture load is complete. Users can disable this with the global flag.\n      if (Texture.USE_DUMMY_1x1_DATA) {\n        self.uploadData(1, 1);\n        this.width = this.height = 0;\n      }\n\n      img.crossOrigin = crossOrigin;\n\n      img.onload = function(ev) {\n        self.uploadImage(img, undefined, undefined, genMipmaps);\n        if (typeof successCB === \"function\") successCB.call(self, ev, self);\n      };\n      img.onerror = function(ev) {\n        if (genMipmaps)\n          //we still need to gen mipmaps on the 1x1 dummy\n          gl.generateMipmap(gl.TEXTURE_2D);\n        if (typeof failCB === \"function\") failCB.call(self, ev, self);\n      };\n      img.onabort = function(ev) {\n        if (genMipmaps) gl.generateMipmap(gl.TEXTURE_2D);\n        if (typeof failCB === \"function\") failCB.call(self, ev, self);\n      };\n\n      img.src = path;\n    }\n    //otherwise see if we have an 'image' specified\n    else if (options.image) {\n      this.uploadImage(\n        options.image,\n        options.format,\n        options.dataType,\n        options.genMipmaps\n      );\n    }\n    //otherwise assume our regular list of width/height arguments are passed\n    else {\n      this.uploadData(\n        options.width,\n        options.height,\n        options.format,\n        options.dataType,\n        options.data,\n        options.genMipmaps\n      );\n    }\n  },\n\n  /**\n   * Called in the Texture constructor, and after the GL context has been re-initialized.\n   * Subclasses can override this to provide a custom data upload, e.g. cubemaps or compressed\n   * textures.\n   *\n   * @method  create\n   */\n  create: function() {\n    this.gl = this.context.gl;\n    var gl = this.gl;\n\n    this.id = gl.createTexture(); //texture ID is recreated\n    this.width = this.height = 0; //size is reset to zero until loaded\n    this.target = gl.TEXTURE_2D; //the provider can change this if necessary (e.g. cube maps)\n\n    this.bind();\n\n    //TODO: clean these up a little.\n    gl.pixelStorei(\n      gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,\n      Texture.UNPACK_PREMULTIPLY_ALPHA\n    );\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, Texture.UNPACK_ALIGNMENT);\n    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, Texture.UNPACK_FLIP_Y);\n\n    var colorspace =\n      Texture.UNPACK_COLORSPACE_CONVERSION || gl.BROWSER_DEFAULT_WEBGL;\n    gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, colorspace);\n\n    //setup wrap modes without binding redundantly\n    this.setWrap(this.wrapS, this.wrapT, false);\n    this.setFilter(this.minFilter, this.magFilter, false);\n\n    if (this.managedArgs) {\n      this.setup(this.managedArgs);\n    }\n  },\n\n  /**\n   * Destroys this texture by deleting the GL resource,\n   * removing it from the WebGLContext management stack,\n   * setting its size to zero, and id and managed arguments to null.\n   *\n   * Trying to use this texture after may lead to undefined behaviour.\n   *\n   * @method  destroy\n   */\n  destroy: function() {\n    if (this.id && this.gl) this.gl.deleteTexture(this.id);\n    if (this.context) this.context.removeManagedObject(this);\n    this.width = this.height = 0;\n    this.id = null;\n    this.managedArgs = null;\n    this.context = null;\n    this.gl = null;\n  },\n\n  /**\n   * Sets the wrap mode for this texture; if the second argument\n   * is undefined or falsy, then both S and T wrap will use the first\n   * argument.\n   *\n   * You can use Texture.Wrap constants for convenience, to avoid needing\n   * a GL reference.\n   *\n   * @method  setWrap\n   * @param {GLenum} s the S wrap mode\n   * @param {GLenum} t the T wrap mode\n   * @param {Boolean} ignoreBind (optional) if true, the bind will be ignored.\n   */\n  setWrap: function(s, t, ignoreBind) {\n    //TODO: support R wrap mode\n    if (s && t) {\n      this.wrapS = s;\n      this.wrapT = t;\n    } else this.wrapS = this.wrapT = s;\n\n    //enforce POT rules..\n    this._checkPOT();\n\n    if (!ignoreBind) this.bind();\n\n    var gl = this.gl;\n    gl.texParameteri(this.target, gl.TEXTURE_WRAP_S, this.wrapS);\n    gl.texParameteri(this.target, gl.TEXTURE_WRAP_T, this.wrapT);\n  },\n\n  /**\n   * Sets the min and mag filter for this texture;\n   * if mag is undefined or falsy, then both min and mag will use the\n   * filter specified for min.\n   *\n   * You can use Texture.Filter constants for convenience, to avoid needing\n   * a GL reference.\n   *\n   * @method  setFilter\n   * @param {GLenum} min the minification filter\n   * @param {GLenum} mag the magnification filter\n   * @param {Boolean} ignoreBind if true, the bind will be ignored.\n   */\n  setFilter: function(min, mag, ignoreBind) {\n    if (min && mag) {\n      this.minFilter = min;\n      this.magFilter = mag;\n    } else this.minFilter = this.magFilter = min;\n\n    //enforce POT rules..\n    this._checkPOT();\n\n    if (!ignoreBind) this.bind();\n\n    var gl = this.gl;\n    gl.texParameteri(this.target, gl.TEXTURE_MIN_FILTER, this.minFilter);\n    gl.texParameteri(this.target, gl.TEXTURE_MAG_FILTER, this.magFilter);\n  },\n\n  /**\n   * A low-level method to upload the specified ArrayBufferView\n   * to this texture. This will cause the width and height of this\n   * texture to change.\n   *\n   * @method  uploadData\n   * @param  {Number} width          the new width of this texture,\n   *                                 defaults to the last used width (or zero)\n   * @param  {Number} height         the new height of this texture\n   *                                 defaults to the last used height (or zero)\n   * @param  {GLenum} format         the data format, default RGBA\n   * @param  {GLenum} type           the data type, default UNSIGNED_BYTE (Uint8Array)\n   * @param  {ArrayBufferView} data  the raw data for this texture, or null for an empty image\n   * @param  {Boolean} genMipmaps\t   whether to generate mipmaps after uploading the data, default false\n   */\n  uploadData: function(width, height, format, type, data, genMipmaps) {\n    var gl = this.gl;\n\n    format = format || gl.RGBA;\n    type = type || gl.UNSIGNED_BYTE;\n    data = data || null; //make sure falsey value is null for texImage2D\n\n    this.width = width || width == 0 ? width : this.width;\n    this.height = height || height == 0 ? height : this.height;\n\n    this._checkPOT();\n\n    this.bind();\n\n    gl.texImage2D(\n      this.target,\n      0,\n      format,\n      this.width,\n      this.height,\n      0,\n      format,\n      type,\n      data\n    );\n\n    if (genMipmaps) gl.generateMipmap(this.target);\n  },\n\n  /**\n   * Uploads ImageData, HTMLImageElement, HTMLCanvasElement or\n   * HTMLVideoElement.\n   *\n   * @method  uploadImage\n   * @param  {Object} domObject the DOM image container\n   * @param  {GLenum} format the format, default gl.RGBA\n   * @param  {GLenum} type the data type, default gl.UNSIGNED_BYTE\n   * @param  {Boolean} genMipmaps whether to generate mipmaps after uploading the data, default false\n   */\n  uploadImage: function(domObject, format, type, genMipmaps) {\n    var gl = this.gl;\n\n    format = format || gl.RGBA;\n    type = type || gl.UNSIGNED_BYTE;\n\n    this.width = domObject.width;\n    this.height = domObject.height;\n\n    this._checkPOT();\n\n    this.bind();\n\n    gl.texImage2D(this.target, 0, format, format, type, domObject);\n\n    if (genMipmaps) gl.generateMipmap(this.target);\n  },\n\n  uploadSubImage: function() {},\n\n  /**\n   * If FORCE_POT is false, we verify this texture to see if it is valid,\n   * as per non-power-of-two rules. If it is non-power-of-two, it must have\n   * a wrap mode of CLAMP_TO_EDGE, and the minification filter must be LINEAR\n   * or NEAREST. If we don't satisfy these needs, an error is thrown.\n   *\n   * @method  _checkPOT\n   * @private\n   * @return {[type]} [description]\n   */\n  _checkPOT: function() {\n    if (!Texture.FORCE_POT) {\n      //If minFilter is anything but LINEAR or NEAREST\n      //or if wrapS or wrapT are not CLAMP_TO_EDGE...\n      var wrongFilter =\n        this.minFilter !== Texture.Filter.LINEAR &&\n        this.minFilter !== Texture.Filter.NEAREST;\n      var wrongWrap =\n        this.wrapS !== Texture.Wrap.CLAMP_TO_EDGE ||\n        this.wrapT !== Texture.Wrap.CLAMP_TO_EDGE;\n\n      if (wrongFilter || wrongWrap) {\n        if (!isPowerOfTwo(this.width) || !isPowerOfTwo(this.height))\n          throw new Error(\n            wrongFilter\n              ? \"Non-power-of-two textures cannot use mipmapping as filter\"\n              : \"Non-power-of-two textures must use CLAMP_TO_EDGE as wrap\"\n          );\n      }\n    }\n  },\n\n  /**\n   * Binds the texture. If unit is specified,\n   * it will bind the texture at the given slot\n   * (TEXTURE0, TEXTURE1, etc). If unit is not specified,\n   * it will simply bind the texture at whichever slot\n   * is currently active.\n   *\n   * @method  bind\n   * @param  {Number} unit the texture unit index, starting at 0\n   */\n  bind: function(unit) {\n    var gl = this.gl;\n    if (unit || unit === 0) gl.activeTexture(gl.TEXTURE0 + unit);\n    gl.bindTexture(this.target, this.id);\n  },\n\n  toString: function() {\n    return this.id + \":\" + this.width + \"x\" + this.height + \"\";\n  },\n\n  shape: {\n    get: function() {\n      this.__shape[0] = this.width;\n      this.__shape[1] = this.height;\n      return this.__shape;\n    },\n    set: function(shape) {\n      throw new Error(\"changing shape not supported\");\n    }\n  }\n});\n\n/**\n * A set of Filter constants that match their GL counterparts.\n * This is for convenience, to avoid the need for a GL rendering context.\n *\n * @example\n * ```\n *     Texture.Filter.NEAREST\n *     Texture.Filter.NEAREST_MIPMAP_LINEAR\n *     Texture.Filter.NEAREST_MIPMAP_NEAREST\n *     Texture.Filter.LINEAR\n *     Texture.Filter.LINEAR_MIPMAP_LINEAR\n *     Texture.Filter.LINEAR_MIPMAP_NEAREST\n * ```\n * @attribute Filter\n * @static\n * @type {Object}\n */\nTexture.Filter = {\n  NEAREST: 9728,\n  NEAREST_MIPMAP_LINEAR: 9986,\n  NEAREST_MIPMAP_NEAREST: 9984,\n  LINEAR: 9729,\n  LINEAR_MIPMAP_LINEAR: 9987,\n  LINEAR_MIPMAP_NEAREST: 9985\n};\n\n/**\n * A set of Wrap constants that match their GL counterparts.\n * This is for convenience, to avoid the need for a GL rendering context.\n *\n * @example\n * ```\n *     Texture.Wrap.CLAMP_TO_EDGE\n *     Texture.Wrap.MIRRORED_REPEAT\n *     Texture.Wrap.REPEAT\n * ```\n * @attribute Wrap\n * @static\n * @type {Object}\n */\nTexture.Wrap = {\n  CLAMP_TO_EDGE: 33071,\n  MIRRORED_REPEAT: 33648,\n  REPEAT: 10497\n};\n\n/**\n * A set of Format constants that match their GL counterparts.\n * This is for convenience, to avoid the need for a GL rendering context.\n *\n * @example\n * ```\n *     Texture.Format.RGB\n *     Texture.Format.RGBA\n *     Texture.Format.LUMINANCE_ALPHA\n * ```\n * @attribute Format\n * @static\n * @type {Object}\n */\nTexture.Format = {\n  DEPTH_COMPONENT: 6402,\n  ALPHA: 6406,\n  RGBA: 6408,\n  RGB: 6407,\n  LUMINANCE: 6409,\n  LUMINANCE_ALPHA: 6410\n};\n\n/**\n * A set of DataType constants that match their GL counterparts.\n * This is for convenience, to avoid the need for a GL rendering context.\n *\n * @example\n * ```\n *     Texture.DataType.UNSIGNED_BYTE\n *     Texture.DataType.FLOAT\n * ```\n * @attribute DataType\n * @static\n * @type {Object}\n */\nTexture.DataType = {\n  BYTE: 5120,\n  SHORT: 5122,\n  INT: 5124,\n  FLOAT: 5126,\n  UNSIGNED_BYTE: 5121,\n  UNSIGNED_INT: 5125,\n  UNSIGNED_SHORT: 5123,\n  UNSIGNED_SHORT_4_4_4_4: 32819,\n  UNSIGNED_SHORT_5_5_5_1: 32820,\n  UNSIGNED_SHORT_5_6_5: 33635\n};\n\n/**\n * The default wrap mode when creating new textures. If a custom\n * provider was specified, it may choose to override this default mode.\n *\n * @attribute {GLenum} DEFAULT_WRAP\n * @static\n * @default  Texture.Wrap.CLAMP_TO_EDGE\n */\nTexture.DEFAULT_WRAP = Texture.Wrap.CLAMP_TO_EDGE;\n\n/**\n * The default filter mode when creating new textures. If a custom\n * provider was specified, it may choose to override this default mode.\n *\n * @attribute {GLenum} DEFAULT_FILTER\n * @static\n * @default  Texture.Filter.LINEAR\n */\nTexture.DEFAULT_FILTER = Texture.Filter.NEAREST;\n\n/**\n * By default, we do some error checking when creating textures\n * to ensure that they will be \"renderable\" by WebGL. Non-power-of-two\n * textures must use CLAMP_TO_EDGE as their wrap mode, and NEAREST or LINEAR\n * as their wrap mode. Further, trying to generate mipmaps for a NPOT image\n * will lead to errors.\n *\n * However, you can disable this error checking by setting `FORCE_POT` to true.\n * This may be useful if you are running on specific hardware that supports POT\n * textures, or in some future case where NPOT textures is added as a WebGL extension.\n *\n * @attribute {Boolean} FORCE_POT\n * @static\n * @default  false\n */\nTexture.FORCE_POT = false;\n\n//default pixel store operations. Used in create()\nTexture.UNPACK_FLIP_Y = false;\nTexture.UNPACK_ALIGNMENT = 1;\nTexture.UNPACK_PREMULTIPLY_ALPHA = true;\nTexture.UNPACK_COLORSPACE_CONVERSION = undefined;\n\n//for the Image constructor we need to handle things a bit differently..\nTexture.USE_DUMMY_1x1_DATA = true;\n\n/**\n * Utility to get the number of components for the given GLenum, e.g. gl.RGBA returns 4.\n * Returns null if the specified format is not of type DEPTH_COMPONENT, ALPHA, LUMINANCE,\n * LUMINANCE_ALPHA, RGB, or RGBA.\n *\n * @method getNumComponents\n * @static\n * @param  {GLenum} format a texture format, i.e. Texture.Format.RGBA\n * @return {Number} the number of components for this format\n */\nTexture.getNumComponents = function(format) {\n  switch (format) {\n    case Texture.Format.DEPTH_COMPONENT:\n    case Texture.Format.ALPHA:\n    case Texture.Format.LUMINANCE:\n      return 1;\n    case Texture.Format.LUMINANCE_ALPHA:\n      return 2;\n    case Texture.Format.RGB:\n      return 3;\n    case Texture.Format.RGBA:\n      return 4;\n  }\n  return null;\n};\n\nmodule.exports = Texture;\n"]},"metadata":{},"sourceType":"script"}